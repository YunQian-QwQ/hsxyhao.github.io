<html>
  <head>
      <meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Madara</title>
<link rel="shortcut icon" href="https://hsxyhao.github.io/favicon.ico?v=1576226287936">
<link rel="stylesheet" href="https://hsxyhao.github.io/styles/main.css">
<meta name="description" content="这个人很懒，什么都不想写..." />

<link rel="stylesheet" href="/media/fonts/iconfont.css">
<link href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Rosario:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  </head>
  <body>
    <div class="head-top-line"></div>
    <div class="header-box">
      <header class="header">
  <div class="blog-header">
    <div class="site-meta">
      <div class="nav-toggle" id="nav_toggle">
        <div class="toggle-box">
          <div class="line line-top"></div>
          <div class="line line-center"></div>
          <div class="line line-bottom"></div>
        </div>
      </div>
      <div class="site-title">
        <a href="/" class="brand">
          <span>Madara</span>
        </a>
      </div>
      <p class="subtitle">Quick notes</p>
    </div>
    <nav class="site-nav" id="site_nav">
      <ul>
        <li class="nav-item ">
          
            
              
                <a href="/">
                  <i class="iconfont icon-home"></i> 首页
                </a>
              
            
          
            
          
            
          
            
          
        </li>
        <li class="nav-item ">
          
            
          
            
              
                <a href="/archives">
                  <i class="iconfont icon-archive"></i> 归档
                </a>
              
            
          
            
          
            
          
        </li>
        <li class="nav-item ">
          
            
          
            
          
            
              
                <a href="/tags">
                  <i class="iconfont icon-tags"></i> 标签
                </a>
              
            
          
            
          
        </li>
        <li class="nav-item">
          <a>
            <i class="iconfont icon-search"></i> 搜索
          </a>
        </li>
      </ul>
    </nav>
  </div>
</header>
<script type="text/javascript"> 
 
  let showNav = true;

  let navToggle = document.querySelector('#nav_toggle'),
  siteNav = document.querySelector('#site_nav');
  
  function initEvent() {
    navToggle.addEventListener('click',navClick);
  }

  function navClick() {
    navToggle.classList.toggle('nav-toggle-active');
    siteNav.classList.toggle('nav-menu-active');
  }

  window.addEventListener("load", initEvent);
  
</script>
    </div>
    <div class="main-continer">
      <div class="section-layout">
        <div class="section-layout-wrapper">
          <div class="sidebar">
  <div class="sidebar-wrapper">
    <div class="post-list-sidebar">
      <div class="sidebar-title">
        <span class="sidebar-title-item sidebar-title-active">文章目录</span>
        <span class="sidebar-title-item">站点概览</span>
      </div>
    </div>
    <div class="post-sidebar-body">
      <div class="post-toc">
        <ul class="markdownIt-TOC">
<li><a href="#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E7%9A%84%E9%97%AE%E9%A2%98">主从复制的问题</a></li>
<li><a href="#redis-sentinel">Redis Sentinel</a>
<ul>
<li><a href="#%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F%E6%8B%93%E6%89%91%E5%9B%BE">哨兵模式拓扑图</a></li>
<li><a href="#sentinel%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%8A%9F%E8%83%BD">Sentinel实现的功能</a></li>
<li><a href="#%E9%83%A8%E7%BD%B2">部署</a></li>
<li><a href="#%E9%85%8D%E7%BD%AE%E8%A7%A3%E6%9E%90">配置解析</a></li>
<li><a href="#%E5%A4%9A%E8%8A%82%E7%82%B9%E7%9B%91%E6%8E%A7">多节点监控</a></li>
<li><a href="#%E5%AE%A2%E6%88%B7%E7%AB%AF">客户端</a></li>
<li><a href="#sentinel%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86">sentinel实现原理</a>
<ul>
<li><a href="#%E5%AE%9A%E6%97%B6%E7%9B%91%E6%8E%A7">定时监控</a></li>
<li><a href="#%E4%B8%BB%E5%AE%A2%E8%A7%82%E4%B8%8B%E7%BA%BF">主/客观下线</a></li>
<li><a href="#%E9%A2%86%E5%AF%BC%E9%80%89%E4%B8%BE">领导选举</a></li>
<li><a href="#%E6%95%85%E9%9A%9C%E8%BD%AC%E7%A7%BB">故障转移</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#redis-cluster">Redis Cluster</a>
<ul>
<li><a href="#%E6%95%B0%E6%8D%AE%E5%88%86%E5%B8%83">数据分布</a>
<ul>
<li><a href="#%E7%AE%97%E6%B3%95%E4%BB%8B%E7%BB%8D">算法介绍</a></li>
</ul>
</li>
<li><a href="#%E6%90%AD%E5%BB%BA%E9%9B%86%E7%BE%A4">搭建集群</a></li>
<li><a href="#%E8%8A%82%E7%82%B9%E9%80%9A%E4%BF%A1">节点通信</a></li>
<li><a href="#%E9%9B%86%E7%BE%A4%E4%BC%B8%E7%BC%A9">集群伸缩</a></li>
<li><a href="#%E8%AF%B7%E6%B1%82%E8%B7%AF%E7%94%B1">请求路由</a></li>
</ul>
</li>
</ul>

      </div>
      <div class="post-side-meta"></div>
    </div>
  </div>
</div>
<script></script>
          <div class="section-box">
            <div class="section">
              <div class="article-box">
    <header class="post-header">
  <h1 class="post-title">
    <a class="post-title-link" href="https://hsxyhao.github.io/post/redis-gao-ke-yong">
      Redis高可用
    </a>
  </h1>
  <div class="post-meta">
    <span class="meta-item">
      <i class="iconfont icon-calendar_empty"></i>
      <span class="pc-show">发布于</span>
      <span>2019-11-23</span>
    </span>
    
      <span class="meta-item">
        <span class="post-meta-divider">|</span>
        <i class="iconfont icon-folder_open_alt"></i>
        <span class="pc-show">分类于</span>
        
          
            <a href="https://hsxyhao.github.io/tag/Redis">
              <span>Redis</span>
            </a>
          
        
      </span>
    
    <span class="meta-item">
      <span class="post-meta-divider">|</span>
      <i class="iconfont icon-time"></i>
      <span>18分钟</span>
    </span>
    <span class="meta-item">
      <span class="post-meta-divider">|</span>
      <i class="iconfont icon-keyboard"></i>
      <span class="pc-show">4857字数</span>
    </span>
  </div>
</header>
</div>
              <div class="post-body">
                <p>Redis的高可用实现方案有哪些，为什么要选择官方的哨兵模式，自己开发自动化故障转移脚本有什么问题。redis cluster重定向有几种？redis数据分区...</p>
<!-- more -->
<h1 id="主从复制的问题">主从复制的问题</h1>
<p>一旦主节点发生故障，那么系统的写能力就会崩溃，这个时候需要手动的切换主节点，手动操作的显然不是一个明智的选择，所以redis官方提供了哨兵模式。</p>
<p><strong>试想一下如果发生故障，人工操作的流程应该是怎么样的？</strong></p>
<ol>
<li>在多个从节点中选择一个节点作为新的主节点</li>
<li>对新的主节点执行slaveof no one</li>
<li>其他从节点切换到新的主节点并开始进行数据同步</li>
<li>主从节点重启后在同步新节点的数据</li>
</ol>
<p>大多数手动操作流程都是以上几个步骤，需要人工介入的方案并不是一个高可用的方案。即使使用脚本代替人工操作的方案，但是还是需要考虑以下几个问题：</p>
<ul>
<li>主节点故障，需要手动切换主节点，同步应用方的主节点地址更新，以及其他从节点同步新主节点数据</li>
<li>主节点的写能力受到单机的限制</li>
<li>主节点的存储能力受到单机的限制</li>
</ul>
<blockquote>
<p>最后两个问题应该归类为分布式类别，但是由于主从复制模式也存在这种问题，所以也列举出来。主从复制最主要的问题还是第一个问题，手动切换如果不及时的话，会给应用方数据带来一定的错误，其次故障转义在实时性以及准确性上也无法得到保障。</p>
</blockquote>
<h1 id="redis-sentinel">Redis Sentinel</h1>
<p>主节点发生故障时，Redis Sentinel能自动完成故障发现和转移。哨兵模式解决了哪些问题，为什么不直接使用脚本代替人工操作，要单独使用哨兵模式呢？</p>
<blockquote>
<p>建议使用Redis 2.8以上的版本</p>
</blockquote>
<p><strong>自动化脚本仍然无法解决的问题?</strong></p>
<ul>
<li>一、判断节点不可达的机制是否健全和标准(为什么哨兵模式中会有多个sentinel节点)</li>
<li>二、怎么保证只有一个从节点晋升为主节点(多从节点的情况下)</li>
<li>三、通知客户端更新主节点ip是否健壮</li>
</ul>
<h2 id="哨兵模式拓扑图">哨兵模式拓扑图</h2>
<p>哨兵模式是为了解决主从复制一系列问题产生的，本质上是不会修改主从复制的结构，只是在其基础上进行扩展，也就是多了一些sentinel节点，其实这里的sentinel节点也是一种特殊的redis服务几点。</p>
<figure data-type="image" tabindex="1"><img src="https://hsxyhao.github.io/post-images/1574667620983.png" alt=""></figure>
<p><strong>故障转移步骤</strong></p>
<ol>
<li>主节点出现故障，从节点与主节点的连接断开，主从复制失败。</li>
<li>每个sentinel节点通过定期监控查看主节点是否出现故障。</li>
<li>如果有多个sentinel节点都检测出主节点出现故障，则会选举出一个leader sentinel来负责故障转移的主要任务。</li>
<li>开始进行故障转移<br>
<img src="https://hsxyhao.github.io/post-images/1574668587748.png" alt=""></li>
</ol>
<blockquote>
<p>第四步将之前的主节点变为从节点，是在该节点可以重启之后进行的操作。</p>
</blockquote>
<ol start="5">
<li>完成故障转移</li>
</ol>
<h2 id="sentinel实现的功能">Sentinel实现的功能</h2>
<p>要想完成以上的故障转移任务，sentinel节点必须要具有以下几个功能才行</p>
<ol>
<li>监控：Sentinel节点会定期检测redis主节点以及其余的sentinel节点</li>
<li>通知：通知应用方修改最新的mater节点信息</li>
<li>主节点故障转移：实现从节点晋升为主节点</li>
<li>配置提供者：Redis Sentinel客户端中可以获取到主节点相关的信息</li>
</ol>
<blockquote>
<p>为什么sentinel节点要有多个？</p>
<ul>
<li>防止对主节点故障产生误判</li>
<li>防止sentinel节点的单点故障</li>
</ul>
</blockquote>
<h2 id="部署">部署</h2>
<p>先配置一个主从结构的集群，在此基础上配置哨兵节点，配置文件可以使用src目录下默认的sentinel.conf文件，不同节点的配置文件将端口修改一下。<br>
启动方式：</p>
<ol>
<li>使用redis-sentinel命令</li>
</ol>
<pre><code class="language-java">redis-sentinel redis-sentinel-23679.conf
</code></pre>
<ol start="2">
<li>redis-server 命令外加--sentinel 参数</li>
</ol>
<pre><code class="language-java">redis-server redis-sentinel-23679.cconf --sentinel
</code></pre>
<ol start="3">
<li>使用info Sentinel查看配置详情</li>
</ol>
<blockquote>
<p>部署成功之后sentinel对应节点的配置文件会出现一些变化，parallel-syncs、failover-timeout配置参数，其次还会新增sentinel known-replica(从节点)、sentinel known-sentinel(其它sentinel节点)等。</p>
</blockquote>
<h2 id="配置解析">配置解析</h2>
<pre><code class="language-java">sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;port&gt; &lt;quorum&gt;
</code></pre>
<p>ip和port表示主节点的地址，quorum和sentinel选举有关，在进行故障转移时会选举出一个leader进行故障转移，选举的算法为raft，quorum代表的是节点得到的票数只要大于quorum就会被选举为leader，但是quorum一般要大于半数。</p>
<pre><code class="language-java">sentinel down-after-milliseconds &lt;master-name&gt; &lt;times&gt;
</code></pre>
<p>这个代表的是sentinel leader节点发送给follower节点以及redis主从节点的超时时间，如果超过这个时间则判断该节点不可达。times设置越大应用的延迟越高，设置的过小有可能会造成节点不可达误判。</p>
<pre><code class="language-java">sentinel parallel-syncs &lt;master-name&gt; &lt;nums&gt;
</code></pre>
<p>表示选出新的主节点之后，允许多少个从节点同时进行复制操作，虽然复制操作时会fork出一个子进行程不会阻塞redis服务，但是会主节点所在机器的IO以及网络资源。</p>
<pre><code class="language-java">sentinel failover-timeout
</code></pre>
<p>有些复杂，暂时不做了解</p>
<pre><code class="language-java">sentinel auth-pass &lt;master-name&gt; &lt;password&gt;
</code></pre>
<p>如果主节点设置了requirepass参数配置，那么在部署哨兵服务的时候也要在配置上加上相关的权限校验配置。</p>
<pre><code class="language-java">sentinel notification &lt;master-name&gt; &lt;script-path&gt;
// 脚本demo
#!/bin/sh
#获取所有参数
msg=$*
# 报警脚本或者接口，将msg作为参数
exit 0
</code></pre>
<p>在故障转移期间，当出现警告级别的事时（客官下线，主管下线）会触发相应的脚本，执行脚本时会传递相应的参数信息，这些参数信息可以用来发送邮件通知开发人员。</p>
<pre><code class="language-java">sentinel client-reconfig-script &lt;master-name&gt; &lt;script-path&gt;
// 脚本demo
#!/bin/sh
#获取所有参数
msg=$*
# 报警脚本或者接口，将msg作为参数
exit 0
</code></pre>
<p>和notification脚本触发时间有些区别，该脚本是在故障转移成功之后触发。</p>
<blockquote>
<p>关于notification和reconfig脚本限制条件</p>
<ul>
<li>可执行权限，即使用chmod 777修改权限</li>
<li>必须是shell脚本，即包含shell脚本头(#!/bin/sh)</li>
<li>脚本最大执行不可以超过60s，如果超过了就会被kill</li>
<li>如果redis sentinel节点过多，不建议使用脚本的方式进行通知</li>
<li>exit 0正常退出，exit 1脚本稍后重试，exit 2(&gt;=2)不会重试</li>
</ul>
</blockquote>
<h2 id="多节点监控">多节点监控</h2>
<p>这里是指如何使用sentinel监控多个redis主从复制集群，在介绍上面配置的时候，所有的配置都有一个master-name参数，如果想要监控多个集群，那么只需要将所有监控命令重新在一个配置文件中再写一遍，用master-name区分。</p>
<h2 id="客户端">客户端</h2>
<p>如果使用了哨兵模式的集群，那么对应的客户端也需要做调整，传统的jedis使用方式就已经不支持了需要被替换。具体的使用方式不会介绍，内容太多了不方便记忆，而且使用方式内容和redis的原理性的内容稍微有点不一样，后面单独记录在项目中怎么使用redis-sentinel集群模式。</p>
<h2 id="sentinel实现原理">sentinel实现原理</h2>
<h3 id="定时监控">定时监控</h3>
<ol>
<li>10秒<br>
每隔10秒，每个sentinel节点会向主节点和从节点发送info命令获取最新的拓扑结构。</li>
</ol>
<blockquote>
<p>这就是为什么在配置sentinel节点的时候不需要添加从节点的信息了，对主节点使用info命令会返回主从复制的结构信息。</p>
</blockquote>
<ol start="2">
<li>2秒<br>
每个sentinel节点（不包含redis服务节点）每隔两秒向redis数据节点上的_sentinel_:hello频道发送该sentinel节点对于主节点的判断以及当前sentinel节点的信息，并且每个sentinel还会订阅该频道来了解其他节点对于主节点的判断。主要作用：</li>
</ol>
<ul>
<li>发现新的sentinel节点，将自己的信息保存在_sentinel_:hello频道上，共享给其他sentinel节点</li>
<li>sentinel交换主节点的状态，作为后面客官下线以及领导者选举的依据，从而使节点不可达的健全性得到保障。</li>
</ul>
<blockquote>
<p>这段完全摘自《Redis开发与运维》第九章5小节，自己总结的实在是无法直视，索性直接搬过来。之前在实践redis sentinel集群模式的时候，发现sentinel配置文件中并没有配置几个节点关联起来监控一个redis集群，但是在启动之后，却发现redis集群可以被一个sentinel集群节点监控，当时自己就比较懵，我想此处应该就可以解决当时的困扰。</p>
</blockquote>
<ol start="3">
<li>1秒<br>
1秒的定时监控主要是用来做心跳检测的，sentinel节点每隔一秒钟会向所有节点（主从节点，其他sentinel节点）发送一次心跳。</li>
</ol>
<p><strong>redis sentinel监控图</strong><br>
<img src="https://hsxyhao.github.io/post-images/1574844918230.png" alt=""></p>
<blockquote>
<p>本来准备摘自《Redis开发与运维》上的图，但是发现三张图有些占地方，所以就自己画了张图，由于画图软件的原因有两个地方画不出来就没有弄了，不过不影响整体。虽然有些复杂但是如果把这个屡清楚了三个定时任务具体的功能也就清楚了。</p>
</blockquote>
<h3 id="主客观下线">主/客观下线</h3>
<p><strong>主观下线</strong><br>
当sentinel节点向redis服务节点发送ping心跳时，在down-after-milliseconds内服务没有回复的话就会被当前sentinel节点作失败判定，这个过程称为主观下线。<br>
<strong>客观下线</strong><br>
当被判定的节点是主节点的时候，那么该sentinel节点就会向其他节点询问主节点的状态，如果超过quorum个节点都判定为下线，那么就会做出客观下线的决定。</p>
<blockquote>
<p>向其他sentinel节点询问master节点的状况使用的是sentine is-master-down-by-addr命令，这里不做介绍。</p>
</blockquote>
<h3 id="领导选举">领导选举</h3>
<p>当对master节点做出客观下线后，不会立马进行故障转移操作，首先会在所有的sentinel节点中选出一个leader来进行故障转移操作。通过raft算法选举出leader节点，关于raft算法书中介绍的不是很详细，这里提供两个资料帮助理解raft算法。</p>
<ul>
<li><a href="http://thesecretlivesofdata.com/raft/">raft算法动画演示</a></li>
<li><a href="https://www.bilibili.com/video/av61558449/">b站白话讲解raft共识算法</a></li>
</ul>
<h3 id="故障转移">故障转移</h3>
<p>在选出leader节点之后就会进行故障转移操作，故障转移操作也很简单，在进行转移的时候对从节点的信息做一些简单的判断，过滤出最优从节点晋升。具体过程如下：<br>
<img src="https://hsxyhao.github.io/post-images/1574845720018.png" alt=""></p>
<ol>
<li>选择出新的主节点<br>
1). 过滤出所有不健康的节点(主观下线、断线)，5秒内没有回复过sentinel节点，以及与主节点失联超过down-after-milliseconds * 10秒。<br>
2). 判断有没有优先级高的从节点，即在配置文件中配置slave-priority属性的节点。<br>
3). 选择复制偏移量最大的节点，即数据最接近主节点的从节点。<br>
4). 选择runid最小的从节点(?)</li>
<li>对选择出来的从节点执行slaveof no one命令，和之前的手动操作类似。</li>
<li>sentinel节点会向其余的从节点发送命令，成为新主节点的从节点。</li>
<li>持续关注已经挂掉的主节点，一旦联系上，就将他变为新的主节点的从节点。</li>
</ol>
<h1 id="redis-cluster">Redis Cluster</h1>
<p>redis cluster可以理解为是一种水平扩展的方式，将数据分散在多个节点上，解决单机内存瓶颈限制。</p>
<h2 id="数据分布">数据分布</h2>
<p>在分布式缓存中，需要怎样将数据存储在多个节点中，并且读取时还能正常获取到对应的值？一般有以下方法来解决该问题，节点取余算法、一致性哈希算法以及redis使用的虚拟槽分区算法。</p>
<h3 id="算法介绍">算法介绍</h3>
<ol>
<li>节点取余分区<br>
节点取余算法就是对其key进行hash，得到hash值后对其进行服务节点数取模，得出的值便是对应的服务器位置。</li>
</ol>
<p>优点：</p>
<ul>
<li>易理解、便实现</li>
</ul>
<p>缺点：</p>
<ul>
<li>无法支持节点伸缩，即加机器和减机器</li>
</ul>
<ol start="2">
<li>一致性哈希分区<br>
首先抽象出一个哈希环，就是将一个环N（0~2<sup>32</sup>）份，将key哈希取值后的值顺时针映射到哈希环上的点。</li>
</ol>
<blockquote>
<p>为什么要顺时针映射，hash(key)的值不一定会刚好落在哈希环的节点上，这里的节点即数据服务节点，这时需要找到最近的一个数据节点，其实不论顺时针还是逆时针都可以，但是必须要统一，否则在查询的时候就会获取不到数据。</p>
</blockquote>
<p>优点：</p>
<ul>
<li>在只影响少量数据的情况下支持节点伸缩</li>
</ul>
<p>缺点：</p>
<ul>
<li>实现起来稍微麻烦一点</li>
<li>当节点数过少时，进行节点伸缩还是会影响到大部分数据</li>
</ul>
<ol start="3">
<li>虚拟槽分区<br>
将数据和节点通过槽进行解耦，抽象出一个具有16384个槽位的点，并且每个数据服务节点均分这些槽的管理权，hash(key)的值先通过虚拟槽的映射，然后找到对应的存储数据节点。</li>
</ol>
<p>优点：</p>
<ul>
<li>支持节点伸缩</li>
<li>通过解耦的方法降低了节点伸缩的难度</li>
</ul>
<p>缺点：</p>
<ul>
<li>不支持部分redis命令</li>
</ul>
<h2 id="搭建集群">搭建集群</h2>
<p>使用redis命令手动搭建一下集群，体会一下吐血的感受😫，搭建一个简单的小集群，只需要启动6个数据服务节点，不需要太多，不过有几点要注意。下面将展示搭建集群中用到的命令以及注意点的地方：<br>
命令：</p>
<pre><code class="language-java">cluster info
</code></pre>
<p>在redis客户端中使用这个命令可以查看到当前集群的信息，该命令只能查看到客户端连接集群节点信息，其他节点不能查看</p>
<pre><code class="language-java">cluster meet {host} {ip}
</code></pre>
<p>节点握手，使用该命令可以将一个新节点添加到集群中</p>
<pre><code class="language-java">cluster nodes
</code></pre>
<p>查看整个集群的拓扑信息，可以在输出的信息中了解到整个集群的节点信息、主从角色信息以及虚拟槽位点</p>
<pre><code class="language-java">cluster replicate nodeId
</code></pre>
<p>在集群中一般每个节点都会有一个从节点，主要是防止单点故障，使用该命令可以是当前节点与指定nodeId的节点建立主从关系，当前节点为从节点。当前节点需要已经添加到集群环境中。</p>
<pre><code class="language-java">redis-cli -h {host} -p {port} cluster addslots {0..16838}
</code></pre>
<p>在建立好集群关系后，还要为每个客户端分配槽，这里只对集群中主节点进行分配，只有当<strong>分配完16383</strong>个槽位之后集群才会处于上线状态。{a..b}为批量添加，即将a~b个槽位添加到节点中，且为闭区间，删除槽位可以使用delslots命令。</p>
<pre><code class="language-java">cluster forget nodeId
</code></pre>
<p>将节点移除集群环境，一般在集群下线之后会将使用该命令退出集群。</p>
<pre><code class="language-java">cluster keyslot key
</code></pre>
<p>计算出当前key的槽位，在集群环境中添加数据只有key属于那个槽位才能添加到节点中，否则会出现MODED错误信息。</p>
<blockquote>
<p>除了手动搭建节点，还可以使用官方提供的工具包搭建，但是要安装ruby环境，所以这里就不多做记录。</p>
</blockquote>
<p>注意：</p>
<ol>
<li>所有槽点都需要分配完才能进行读写</li>
<li>在本机搭建集群的时候最好是将所有的关于集群的配置文件烦放在一个目录下，方便管理</li>
<li>搭建好集群后，可以添加点数据到集群中，但是如果添加的数据，经过计算不属于当前节点是添加不进去的，会提示一个MOVED 10850 127.0.0.1:6380类似的错误，表示这个数据的槽位是10850，属于6380节点</li>
</ol>
<p>配置:</p>
<pre><code class="language-java">port 6380
pidfile /var/run/redis_6380.pid
logfile &quot;6380.log&quot;
dbfilename dump-6379.rdb
cluster-enabled yes
cluster-config-file nodes-6380.conf
cluster-node-timeout 15000
</code></pre>
<blockquote>
<p>一般集群实在多机器上部署的，但是我在测试的时候实在本机部署的，所以会增加一写关于端口的配置</p>
</blockquote>
<h2 id="节点通信">节点通信</h2>
<p>redis分布式集群中会通过维护节点元数据信息来保证集群的可用性，常见的元数据维护方式有集中式和P2P两种，redis采用的是后者，以及基于Gossip协议实现节点通信。</p>
<h2 id="集群伸缩">集群伸缩</h2>
<blockquote>
<p>暂时不做学习记录，不知道要记录哪些内容，感觉都是命令操作。</p>
</blockquote>
<h2 id="请求路由">请求路由</h2>
<ol>
<li>
<p>请求重定向（MOVED）<br>
在redis cluster集群环境中，如果将一个数据添加到集群中出现了MOVED错误提示，则表示当前节点不接受该数据，需要将数据添加到对应槽的节点中，这个过程称为请求重定向，在使用redis-cli启动客户端的时候，可以添加-c参数表示开启请求重定向，默认的客户端是不支持的。</p>
</li>
<li>
<p>hash_tag<br>
槽位是根据CRC16函数计算出来的，但是计算的内容并不是整个key，只计算有效内容。有效内容是通过{}包含起来的，这部分内容叫做hash_tag，可以使用hash_tag来进行优化，比如涉及到类似mget这种命令的，一次性获取多个key，但是一般多个key是在多个节点上的，mget是不支持这种场景的，使用hash_tag可以保证将多个key映射到同一个槽中。</p>
</li>
<li>
<p>ASK重定向<br>
ASK重定向是指发生在槽迁移的过程中，槽中的数据还没有迁移完成，数据一部分在源节点中，一部分在目标节点中。ASK重定向时客户端的命令流程：</p>
</li>
<li>
<p>client根据本地slots缓存发送命令到source节点，如果存在则直接执行命令发挥结果给客户端。</p>
</li>
<li>
<p>如果此时键不存在source节点，则会向客户端响应ASK异常信息。</p>
</li>
</ol>
<blockquote>
<p>(error) ASK {slot} {targetIP}:{targetPort}</p>
</blockquote>
<ol start="3">
<li>client从异常提示新提取出节点关键信息，发送asking名到目标节点，如果key存在则返回数据，否则返回不存在信息</li>
</ol>
<blockquote>
<p>之所以命名为ASK重定向，大概就取自asking这个命令吧</p>
</blockquote>
<p>目前对于客户端的重定向分为ASK重定向和MOVED重定向，但是两种重定向在slots缓存上有着本质的区别，ASK重定向不会更新本地的slots缓存，MOVED则会。ASK只是零时的重定向，不确定具体什么时候完成所以根本不需要更新slots缓存。</p>

              </div>
              <div class="post-footer">
                <ul class="post-copyright">
                  <li class="post-copyright-author">
                    <strong>本文作者：</strong>
                    Madara
                  </li>
                  <li class="post-copyright-link">
                    <strong>本文链接：</strong>
                    <a href="https://hsxyhao.github.io/post/redis-gao-ke-yong" title="Redis高可用">https://hsxyhao.github.io/post/redis-gao-ke-yong</a>
                  </li>
                  <li class="post-copyright-license">
                    <strong>版权声明： </strong>
                    本博客所有文章除特别声明外,转载请注明出处！
                  </li>
                </ul>
              </div>
            </div>
          </div>
        </div>
      </div>
      <div class="footer-box">
  <footer class="footer">
    <div class="copyright">
      © 2019-2020 <i class="iconfont icon-heart"></i> HsxyHao
    </div>
    <div class="poweredby">
      <div class="power-left">Power By<a href="https://github.com/hsxyhao"> HsxyHao</a></div>
      <div>Copy<a href="https://github.com/iissnan/hexo-theme-next"> Hexo Next Theme</div>
    </div>
  </footer>
  <div class="back-to-top" id="back_to_top">
    <i class="iconfont icon-arrow_up"></i>
    <span class="scrollpercent">
      <span id="back_to_top_text">100</span>%
    </span>
  </div>
</div>

<script>

  let body = document.body;

  let back2Top = document.querySelector('#back_to_top'),
  back2TopText = document.querySelector('#back_to_top_text');

  function navClick() {
    navToggle.classList.toggle('nav-toggle-active');
    siteNav.classList.toggle('nav-menu-active');
  }

  function scrollAnimation(currentY, targetY) {
    // 获取当前位置方法
    // const currentY = document.documentElement.scrollTop || document.body.scrollTop

    // 计算需要移动的距离
    let needScrollTop = targetY - currentY
    let _currentY = currentY
    setTimeout(() => {
      // 一次调用滑动帧数，每次调用会不一样
      const dist = Math.ceil(needScrollTop / 10)
      _currentY += dist
      window.scrollTo(_currentY, currentY)
      // 如果移动幅度小于十个像素，直接移动，否则递归调用，实现动画效果
      if (needScrollTop > 10 || needScrollTop < -10) {
        scrollAnimation(_currentY, targetY)
      } else {
        window.scrollTo(_currentY, targetY)
      }
    }, 1)
  }

  back2Top.addEventListener("click", function(e) {
    scrollAnimation(body.scrollTop, 0);
    e.stopPropagation();
  });
  
  window.addEventListener('scroll', function(e) {
    let percent = body.scrollTop / (body.scrollHeight - body.clientHeight) * 100;
    if (percent > 1 && !back2Top.classList.contains('back-top-active')) {
      back2Top.classList.add('back-top-active');
    }
    if (percent == 0) {
      back2Top.classList.remove('back-top-active');
    }
    back2TopText.textContent = Math.floor(percent);
  });
</script>
    </div>
  </body>
</html>