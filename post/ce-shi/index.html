<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>测试 | Madara</title>
<link rel="shortcut icon" href="https://hsxyhao.github.io/favicon.ico?v=1578886654708">
<link rel="stylesheet" href="https://hsxyhao.github.io/styles/main.css">
<link rel="stylesheet" href="/media/fonts/font-awesome.css">
<link href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Rosario:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">

<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.ui.min.js"></script>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css" integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js" integrity="sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js" integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"
    onload="renderMathInElement(document.body);"></script>
    <meta name="description" content="测试" />
    <meta name="keywords" content="" />
  </head>
  <body>
    <div class="head-top-line"></div>
    <div class="header-box">
      
<div class=" gemini">
  <header class="header">
    <div class="blog-header" id="header">
      <div class="nav-toggle" id="nav_toggle">
        <div class="toggle-box">
          <div class="line line-top"></div>
          <div class="line line-center"></div>
          <div class="line line-bottom"></div>
        </div>
      </div>
      <div class="site-meta">       
        <div class="site-title">
          
            <a href="/" class="brand">
              <span>Madara</span>
            </a>  
          
        </div>
        
          <p class="subtitle">精于心，简于形</p>
        
      </div>
      <nav class="site-nav" id="site_nav">
        <ul id="nav_ul">
          
            <li class="nav-item ">
              
                <a href="/">
                  <i class="fa fa-home"></i> 首页
                </a>
              
            </li>
          
            <li class="nav-item ">
              
                <a href="/archives">
                  <i class="fa fa-archive"></i> 归档
                </a>
              
            </li>
          
            <li class="nav-item ">
              
                <a href="/tags">
                  <i class="fa fa-tags"></i> 标签
                </a>
              
            </li>
          
            <li class="nav-item ">
              
                <a href="/post/about">
                  <i class="fa fa-user"></i> 关于
                </a>
              
            </li>
          
          <li class="nav-item">
            <a>
              <i class="fa fa-search"></i> 搜索
            </a>
          </li>
        </ul>
      </nav>
    </div>
  </header>
</div>

<script type="text/javascript"> 
 
  let showNav = true;

  let navToggle = document.querySelector('#nav_toggle'),
  siteNav = document.querySelector('#site_nav');
  
  function navClick() {
    let sideBar = document.querySelector('.sidebar');
    let navUl = document.querySelector('#nav_ul');
    navToggle.classList.toggle('nav-toggle-active');
    siteNav.classList.toggle('nav-menu-active');
    if (siteNav.classList.contains('nav-menu-active')) {
      siteNav.style = "height: " + (navUl.children.length * 42) +"px !important";
    } else {
      siteNav.style = "";
    }
  }

  navToggle.addEventListener('click',navClick);  
</script>
    </div>
    <div class="main-continer">
      
      <div class="section-layout gemini">
        <div class="section-layout-wrapper">
          
<div class="sidebar">
    <div class="sidebar-box right-motion" id="sidebar">
      
        <div class="post-list-sidebar">
          <div class="sidebar-title">
            <span id="tocSideBar" class="sidebar-title-item sidebar-title-active">文章目录</span>
            <span id="metaSideBar" class="sidebar-title-item">站点概览</span>
          </div>
        </div>
      
      
      <div class="sidebar-body gemini" id="sidebar_body">
        
          <div class="post-side-meta" id="post_side_meta">
            <div class="sidebar-wrapper">
  <div class="sidebar-item">
    <img class="site-author-image right-motion" src="https://hsxyhao.github.io/images/avatar.png"/>
    <p class="site-author-name">Madara</p>
    <p class="site-description right-motion">这个人很懒，什么都不想写...</p>
  </div>
  <div class="sidebar-item side-item-stat right-motion">
    <div class="sidebar-item-box">
      <a href="/archives/">
        
        <span class="site-item-stat-count">17</span>
        <span class="site-item-stat-name">文章</span>
      </a>
    </div>
    <div class="sidebar-item-box">
      <a href="">
        <span class="site-item-stat-count">6</span>
        <span class="site-item-stat-name">分类</span>
      </a>
    </div>
    <div class="sidebar-item-box">
      <a href="/tags/">
        <span class="site-item-stat-count">6</span>
        <span class="site-item-stat-name">标签</span>
      </a>
    </div>
  </div>
  
  
    
      <div class="sidebar-item">
        <span class="site-item-rss">
            <i class="fa fa-rss"></i>
            <a href="https://hsxyhao.github.io/atom.xml" target="_blank">RSS</a>
        </span>
      </div>
    
  
  
    <div class="sidebar-item sidebar-item-social">
      <div class="social-item">
          
            <a href="https://github.com/hsxyhao">
              <i class="fa fa-github-alt"></i> Github
            </a>
          
          
            <a href="https://juejin.im/user/5a3e49edf265da433562f777">
              <i class="fa fa-graduation-cap"></i> 掘金
            </a>
          
          
            <a href="https://www.jianshu.com/u/70f6fd5b5c33">
              <i class="fa fa-book"></i> 简书
            </a>
          
          
            <a href="" title="/media/images/custom-qq.jpeg">
              <i class="fa fa-twitter"></i> Twitter
            </a>
          
          
            <a class="social-img" href="">
              <img src="/media/images/custom-wechat.jpeg" />
              <i class="fa fa-wechat "></i> 微信
            </a>
          
          
            <a class="social-img" href="">
              <img src="/media/images/custom-qq.jpeg" />
              <i class="fa fa-qq"></i> QQ
            </a>
          
          
      </div>
    </div>
  

  <div class="sidebar-item right-motion sidebar-item-friends">
    <p class="friends-title"><i class="fa fa-globe"></i> 友情链接</p>
    <div class="friends-box">
      
        <p>
          <a href="https://hsxyhao.github.io/">【hsxyhao】</a>
        </p>
      
    </div>
  </div>

</div>
          </div>
          <div class="post-toc sidebar-body-active" id="post_toc" style="opacity: 1;">
            <div class="toc-box right-motion">
  <div class="toc-wrapper auto-number no_compress" id="toc_wrapper">
    <ul class="markdownIt-TOC">
<li><a href="#%E5%88%9D%E8%AF%86%E6%8C%87%E9%92%88%E5%92%8C%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F">初识指针和指针变量</a>
<ul>
<li><a href="#%E5%AE%9A%E4%B9%89%E6%8C%87%E9%92%88">定义指针</a></li>
<li><a href="#%E5%8F%96%E5%9C%B0%E5%9D%80%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E5%8F%96%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6">取地址运算符和取值运算符</a></li>
<li><a href="#%E9%81%BF%E5%85%8D%E8%AE%BF%E9%97%AE%E6%9C%AA%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E6%8C%87%E9%92%88">避免访问未初始化的指针</a></li>
</ul>
</li>
<li><a href="#%E6%8C%87%E9%92%88%E5%92%8C%E6%95%B0%E7%BB%84">指针和数组</a>
<ul>
<li><a href="#%E6%95%B0%E7%BB%84%E7%9A%84%E5%9C%B0%E5%9D%80">数组的地址</a></li>
<li><a href="#%E6%8C%87%E5%90%91%E6%95%B0%E7%BB%84%E7%9A%84%E6%8C%87%E9%92%88">指向数组的指针</a></li>
<li><a href="#%E6%8C%87%E9%92%88%E7%9A%84%E8%BF%90%E7%AE%97">指针的运算</a></li>
<li><a href="#%E6%8C%87%E9%92%88%E5%92%8C%E6%95%B0%E7%BB%84%E7%9A%84%E5%8C%BA%E5%88%AB">指针和数组的区别</a></li>
<li><a href="#%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88">指针数组？数组指针？</a>
<ul>
<li><a href="#%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84">指针数组</a></li>
<li><a href="#%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88">数组指针</a></li>
</ul>
</li>
<li><a href="#%E6%8C%87%E9%92%88%E5%92%8C%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84">指针和二维数组</a>
<ul>
<li><a href="#array">array</a></li>
<li><a href="#array1">*(array+1)</a></li>
<li><a href="#array12">*(*(array+1)+2)</a></li>
</ul>
</li>
<li><a href="#%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88%E5%92%8C%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84">数组指针和二维数组</a></li>
</ul>
</li>
<li><a href="#void%E6%8C%87%E9%92%88">void指针</a></li>
<li><a href="#null%E6%8C%87%E9%92%88">NULL指针</a></li>
<li><a href="#%E6%8C%87%E5%90%91%E6%8C%87%E9%92%88%E7%9A%84%E6%8C%87%E9%92%88">指向指针的指针</a></li>
<li><a href="#%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84%E5%92%8C%E6%8C%87%E5%90%91%E6%8C%87%E9%92%88%E7%9A%84%E6%8C%87%E9%92%88">指针数组和指向指针的指针</a></li>
<li><a href="#%E5%B8%B8%E9%87%8F%E5%92%8C%E6%8C%87%E9%92%88">常量和指针</a></li>
<li><a href="#%E6%8C%87%E5%90%91%E5%B8%B8%E9%87%8F%E7%9A%84%E6%8C%87%E9%92%88">指向常量的指针</a></li>
<li><a href="#%E5%B8%B8%E9%87%8F%E6%8C%87%E9%92%88">常量指针</a>
<ul>
<li><a href="#%E6%8C%87%E5%90%91%E9%9D%9E%E5%B8%B8%E9%87%8F%E7%9A%84%E5%B8%B8%E9%87%8F%E6%8C%87%E9%92%88">指向非常量的常量指针</a></li>
<li><a href="#%E6%8C%87%E5%90%91%E5%B8%B8%E9%87%8F%E7%9A%84%E5%B8%B8%E9%87%8F%E6%8C%87%E9%92%88">指向常量的常量指针</a></li>
</ul>
</li>
</ul>

  </div>
</div>

<script>

let lastTop = 0, lList = [], hList = [], postBody, lastIndex = -1; 
let active = 'active-show', activeClass = 'active-current';
let tocWrapper = document.querySelector('#toc_wrapper');
let tocContent = tocWrapper.children[0];
let autoNumber = tocWrapper&&tocWrapper.classList.contains('auto-number');

function addTocNumber(elem, deep) {
  if (!elem) {
    return;
  }
  let prop = elem.__proto__;

  if (prop === HTMLUListElement.prototype) {
    for (let i = 0; i < elem.children.length; i++) {
      addTocNumber(elem.children[i], deep + (i + 1) + '.');
    }
  } else if (prop === HTMLLIElement.prototype) {
    // 保存li元素
    lList.push(elem);
    for (let i = 0; i < elem.children.length; i++) {
      let cur = elem.children[i];
      if (cur.__proto__ === HTMLAnchorElement.prototype) {
        if (autoNumber) {
          cur.text =  deep + ' ' + cur.text;
        }
      } else if (cur.__proto__ === HTMLUListElement.prototype) {
        addTocNumber(cur, deep);
      }
    }
  }
}


document.addEventListener('scroll', function(e) {
  if (lList.length <= 0) {
    return;
  }
  let scrollTop = document.body.scrollTop;
  let dir;

  if (lastTop - scrollTop > 0) {
    dir = 'up';
  } else {
    dir = 'down';
  }

  lastTop = scrollTop;
  if (scrollTop <= 0) {
    if (lastIndex >= 0 && lastIndex < hList.length) {
      lList[lastIndex].classList.remove(activeClass);
    }
    return;
  }

  let current = 0, hasFind = false;
  for (let i = 0; i < hList.length; i++) {
    if (hList[i].offsetTop > scrollTop) {
      current = i;
      hasFind = true;
      break;
    }
  }
  if (!hasFind && scrollTop > lList[lList.length - 1].offsetTop) {
    current = hList.length - 1;
  } else {
    current--;
  }
  if (dir === 'down') {
    if (current > lastIndex) {
      addActiveClass(current);
      removeActiveClass(lastIndex) 
      lastIndex = current;
      removeParentActiveClass();
      lList[current] && addActiveLiElemment(lList[current].parentElement,tocContent);
    }
  } else {
    if (current < lastIndex) {
      addActiveClass(current);
      removeActiveClass(lastIndex);
      lastIndex = current;
      removeParentActiveClass();
      lList[current] && addActiveLiElemment(lList[current].parentElement,tocContent);
    }
  }
});

function removeParentActiveClass() {
  let parents = tocContent.querySelectorAll('.'+active)
  parents.forEach(function(elem) {
    elem.classList.remove(active);
  });
}

function addActiveClass(index) {
  if (index >= 0 && index < hList.length) {
    lList[index].classList.add(activeClass);
  }
}

function removeActiveClass(index) {
  if (index >= 0 && index < hList.length) {
    lList[index].classList.remove(activeClass);
  }
}

function addActiveLiElemment(elem, parent) {
  if (!elem || elem === parent) {
    return;
  } else {
    if (elem.__proto__ === HTMLLIElement.prototype) {
      elem.classList.add(active);
    }
    addActiveLiElemment(elem.parentElement, parent);
  }
}

function showToc() {
  if (tocWrapper) {
    postBody = document.querySelector('#post_body');
    for (let i = 0; i < postBody.children.length; i++) {
      if (postBody.children[i].__proto__ === HTMLHeadingElement.prototype) {
        hList.push(postBody.children[i]);
      }
    }
    if (tocWrapper.classList.contains('compress')) {
        tocContent.classList.add('closed');
    } else if (tocWrapper.classList.contains('no_compress')){
      tocContent.classList.add('expanded');
    } else {
      if (hList.length > 10) {
        active = 'active-hidden'
        tocContent.classList.add('closed');
      } else {
        tocContent.classList.add('expanded');
      }
    }
  }
}
addTocNumber(tocContent, '');

window.addEventListener('load', function() {
  showToc();
  document.querySelector('#sidebar').style='display: block;';
  tocWrapper.classList.add('toc-active');
  setTimeout(function() {
    if ("createEvent" in document) {
      let evt = document.createEvent("HTMLEvents");
      evt.initEvent("scroll", false, true);
      document.dispatchEvent(evt);
    }
    else {
      document.fireEvent("scroll");
    }
  }, 500)
})

</script>
          </div>
        
      </div>
    </div>
</div>
<script>
  const SIDEBAR_TITLE_ACTIVE = 'sidebar-title-active';
  const SIDEBAR_BODY_ACTIVE = 'sidebar-body-active';
  const SLIDE_UP_IN = 'slide-up-in';

  let sidebar = document.querySelector('#sidebar'),
  tocSideBar = document.querySelector('#tocSideBar'),
  metaSideBar = document.querySelector('#metaSideBar'),
  postToc = document.querySelector('#post_toc'),
  postSiteMeta = document.querySelector('#post_side_meta'),
  sidebarTitle = document.querySelector('.sidebar-title'),
  sidebarBody = document.querySelector('#sidebar_body');

  tocSideBar && tocSideBar.addEventListener('click', (e) => {
    toggleSidebar(e);
  });

  metaSideBar && metaSideBar.addEventListener('click', (e) => {
    toggleSidebar(e);
  });

  function toggleSidebar(e) {
    let currentTitle = document.querySelector("."+SIDEBAR_TITLE_ACTIVE);
    if (currentTitle == e.srcElement) {
      return ;
    }
    let current, showElement, hideElement;
    if (e.srcElement == metaSideBar) {
      showElement = postSiteMeta;
      hideElement = postToc;
    } else if (e.srcElement == tocSideBar){
      showElement = postToc;
      hideElement = postSiteMeta;
    }
    currentTitle.classList.remove(SIDEBAR_TITLE_ACTIVE);
    e.srcElement.classList.add(SIDEBAR_TITLE_ACTIVE);

    window.Velocity(hideElement, 'stop');
    window.Velocity(hideElement, 'transition.slideUpOut', {
      display: 'none',
      duration: 200,
      complete: function () {
        window.Velocity(showElement, 'transition.slideDownIn', {
          duration: 200
        });
      }
    })
    hideElement.classList.remove(SIDEBAR_BODY_ACTIVE);
    showElement.classList.add(SIDEBAR_BODY_ACTIVE);
  }

  postToc.addEventListener('transitionend', function() {
    this.classList.remove(SLIDE_UP_IN);
  });


  if (sidebarBody.classList.contains('pisces') || sidebarBody.classList.contains('mist')) {
    let hasFix = false;
    let limitTop = document.querySelector('#nav_ul').children.length * 42 + 162;
    window.addEventListener('scroll', function(e) {
    if (document.body.scrollTop >= limitTop) {
      if (!hasFix) {
        sidebar.classList.add('sidebar-fixed');
        hasFix = true;
      }
    } else {
      if (hasFix) {
        sidebar.classList.remove('sidebar-fixed');
        hasFix = false;
      }
    }
  });
  }
  
</script>
          <div class="section-box">
            <div class="section post">
              <div class="article-box">
    <header class="post-header">
  <h1 class="post-title">
    <a class="post-title-link" href="https://hsxyhao.github.io/post/ce-shi">
      测试
    </a>
  </h1>
  <div class="post-meta">
    <span class="meta-item pc-show">
      <i class="fa fa-calendar-o"></i>
      <span>发布于</span>
      <span>2020-01-12</span>
    </span>
    
    <span class="meta-item">
      <i class="fa fa-clock-o"></i>
      <span>28分钟</span>
    </span>
    <span class="meta-item">
      <span class="post-meta-divider">|</span>
      <i class="fa fa-file-word-o"></i>
      <span>7065<span class="pc-show">字数</span></span>
    </span>
  </div>
</header>
</div>
              <div class="post-body next-md-body" id="post_body">
                <p>说到指针，估计还是有很多小伙伴都还是云里雾里的，有点“知其然，而不知其所以然”。但是，不得不说，学了指针，C语言才能算是入门了。指针是C语言的<strong>精华</strong>，可以说，对对指针的掌握程度，<strong>直接决定</strong>了你C语言的编程能力。</p>
<hr>
<p>在讲指针之前，我们先来了解下变量在<strong>内存</strong>中是如何存放的。</p>
<p>在程序中定义一个变量，那么在程序编译的过程中，系统会根据你定义变量的类型来分配<strong>相应尺寸</strong>的内存空间。那么如果要使用这个变量，只需要用变量名去访问即可。</p>
<p>通过变量名来访问变量，是一种<strong>相对安全</strong>的方式。因为只有你定义了它，你才能够访问相应的变量。这就是对内存的基本认知。但是，如果光知道这一点的话，其实你还是不知道内存是如何存放变量的，因为底层是如何工作的，你依旧不清楚。</p>
<p>那么如果要继续深究的话，你就需要把变量在内存中真正的样子是什么搞清楚。内存的最小索引单元是<code>1字节</code>，那么你其实可以把内存比作一个超级大的<strong>字符型数组</strong>。在上一节我们讲过，数组是有下标的，我们是通过数组名和下标来访问数组中的元素。那么内存也是一样，只不过我们给它起了个新名字：<code>地址</code>。每个地址可以存放<strong>1字节</strong>的数据，所以如果我们需要定义一个整型变量，就需要占据4个内存单元。</p>
<p>那么，看到这里你可能就明白了：其实在程序运行的过程中，完全不需要变量名的参与。变量名只是方便我们进行代码的编写和阅读，只有程序员和编译器知道这个东西的存在。而编译器还知道具体的变量名对应的<strong>内存地址</strong>，这个是我们不知道的，因此编译器就像一个桥梁。当读取某一个变量的时候，编译器就会找到变量名所对应的地址，读取对应的值。</p>
<h1 id="初识指针和指针变量">初识指针和指针变量</h1>
<p>那么我们现在就来切入正题，指针是个什么东西呢？</p>
<p>所谓指针，就是内存地址（下文简称地址）。C语言中设立了专门的<strong>指针变量</strong>来存储指针，和<strong>普通变量</strong>不一样的是，指针变量存储的是<strong>地址</strong>。</p>
<h2 id="定义指针">定义指针</h2>
<p>指针变量也有类型，实际上取决于地址指向的值的类型。那么如何定义指针变量呢：</p>
<p>很简单：<code>类型名* 指针变量名</code></p>
<pre><code class="language-c">char* pa;//定义一个字符变量的指针，名称为pa
int* pb;//定义一个整型变量的指针，名称为pb
float* pc;//定义一个浮点型变量的指针，名称为pc
</code></pre>
<p>注意，指针变量一定要和指向的变量的类型一样，不然类型不同可能在内存中所占的位置不同，如果定义错了就可能导致出错。</p>
<h2 id="取地址运算符和取值运算符">取地址运算符和取值运算符</h2>
<p>获取某个变量的地址，使用取地址运算符<code>&amp;</code>，如：</p>
<pre><code class="language-c">char* pa = &amp;a;
int* pb = &amp;f;
</code></pre>
<p>如果反过来，你要访问指针变量指向的数据，那么你就要使用取值运算符<code>*</code>，如：</p>
<pre><code class="language-c">printf(&quot;%c, %d\n&quot;, *pa, *pb);
</code></pre>
<p>这里你可能发现，定义指针的时候也使用了<code>*</code>，这里属于符号的<strong>重用</strong>，也就是说这种符号在不同的地方就有不同的用意：在定义的时候表示<strong>定义一个指针变量</strong>，在其他的时候则用来<strong>获取指针变量指向的变量的值</strong>。</p>
<p>直接通过变量名来访问变量的值称之为<code>直接访问</code>，通过指针这样的形式访问称之为<code>间接访问</code>，因此取值运算符有时候也成为<strong>间接运算符</strong>。</p>
<p>比如：</p>
<pre><code class="language-c">//Example 01
//代码来源于网络，非个人原创
#include &lt;stdio.h&gt;
int main(void)
{
    char a = 'f';
    int f = 123;
    char* pa = &amp;a;
    int* pf = &amp;f;
    
    printf(&quot;a = %c\n&quot;, *pa);
    printf(&quot;f = %d\n&quot;, *pf);
    
    *pa = 'c';
    *pf += 1;
    
    printf(&quot;now, a = %c\n&quot;, *pa);
    printf(&quot;now, f = %d\n&quot;, *pf);
    
    printf(&quot;sizeof pa = %d\n&quot;, sizeof(pa));
    printf(&quot;sizeof pf = %d\n&quot;, sizeof(pf));
    
    printf(&quot;the addr of a is: %p\n&quot;, pa);
    printf(&quot;the addr of f is: %p\n&quot;, pf);
    
    return 0;
}
</code></pre>
<p>程序实现如下：</p>
<pre><code>//Consequence 01
a = f
f = 123
now, a = c
now, f = 124
sizeof pa = 4
sizeof pf = 4
the addr of a is: 00EFF97F
the addr of f is: 00EFF970
</code></pre>
<h2 id="避免访问未初始化的指针">避免访问未初始化的指针</h2>
<pre><code class="language-c">void f()
{
    int* a;
    *a = 10;
}
</code></pre>
<p>像这样的代码是十分危险的。因为指针a到底指向哪里，我们不知道。就和访问未初始化的普通变量一样，会返回一个<strong>随机值</strong>。但是如果是在指针里面，那么就有可能覆盖到<strong>其他的内存区域</strong>，甚至可能是系统正在使用的<strong>关键区域</strong>，十分危险。不过这种情况，系统一般会驳回程序的运行，此时程序会被<strong>中止</strong>并<strong>报错</strong>。要是万一中奖的话，覆盖到一个合法的地址，那么接下来的赋值就会导致一些有用的数据被<strong>莫名其妙地修改</strong>，这样的bug是十分不好排查的，因此使用指针的时候一定要注意初始化。</p>
<h1 id="指针和数组">指针和数组</h1>
<p>有些读者可能会有些奇怪，指针和数组又有什么关系？这俩货明明八竿子打不着井水不犯河水。别着急，接着往下看，你的观点有可能会改变。</p>
<h2 id="数组的地址">数组的地址</h2>
<p>我们刚刚说了，指针实际上就是变量在<strong>内存中的地址</strong>，那么如果有细心的小伙伴就可能会想到，像数组这样的一大摞变量的集合，它的地址是啥呢？</p>
<p>我们知道，从标准输入流中读取一个值到变量中，用的是<code>scanf</code>函数，一般貌似在后面都要加上<code>&amp;</code>，这个其实就是我们刚刚说的<strong>取地址运算符</strong>。如果你存储的位置是指针变量的话，那就不需要。</p>
<pre><code class="language-c">//Example 02
int main(void)
{
    int a;
    int* p = &amp;a;
    
    printf(&quot;请输入一个整数：&quot;);
    scanf(&quot;%d&quot;, &amp;a);//此处需要&amp;
    printf(&quot;a = %d\n&quot;, a);
    
    printf(&quot;请再输入一个整数：&quot;);
    scanf(&quot;%d&quot;, p);//此处不需要&amp;
    printf(&quot;a = %d\n&quot;, a);
    
    return 0;
}
</code></pre>
<p>程序运行如下：</p>
<pre><code>//Consequence 02
请输入一个整数：1
a = 1
请再输入一个整数：2
a = 2
</code></pre>
<p>在普通变量读取的时候，程序需要知道这个变量在内存中的地址，因此需要<code>&amp;</code>来取地址完成这个任务。而对于指针变量来说，本身就是<strong>另外一个</strong>普通变量的<strong>地址信息</strong>，因此直接给出指针的值就可以了。</p>
<p>试想一下，我们在使用<code>scanf</code>函数的时候，是不是也有不需要使用<code>&amp;</code>的时候？就是在读取<strong>字符串</strong>的时候：</p>
<pre><code class="language-c">//Example 03
#include &lt;stdio.h&gt;
int main(void)
{
    char url[100];
    url[99] = '\0';
    printf(&quot;请输入TechZone的域名：&quot;);
    scanf(&quot;%s&quot;, url);//此处也不用&amp;
    printf(&quot;你输入的域名是：%s\n&quot;, url);
    return 0;
}
</code></pre>
<p>程序执行如下：</p>
<pre><code>//Consequence 03
请输入TechZone的域名：www.techzone.ltd
你输入的域名是：www.techzone.ltd
</code></pre>
<p>因此很好推理：数组名其实就是一个<strong>地址信息</strong>，实际上就是数组<strong>第一个元素的地址</strong>。咱们试试把第一个元素的地址和数组的地址做个对比就知道了：</p>
<pre><code class="language-c">//Example 03 V2
#include &lt;stdio.h&gt;
int main(void)
{
    char url[100];
    printf(&quot;请输入TechZone的域名：&quot;);
    url[99] = '\0';
    scanf(&quot;%s&quot;, url);
    printf(&quot;你输入的域名是：%s\n&quot;, url);

    printf(&quot;url的地址为：%p\n&quot;, url);
    printf(&quot;url[0]的地址为：%p\n&quot;, &amp;url[0]);

    if (url == &amp;url[0])
    {
        printf(&quot;两者一致！&quot;);
    }
    else
    {
        printf(&quot;两者不一致！&quot;);
    }
    return 0;
}
</code></pre>
<p>程序运行结果为：</p>
<pre><code>//Comsequense 03 V2
请输入TechZone的域名：www.techzone.ltd
你输入的域名是：www.techzone.ltd
url的地址为：0063F804
url[0]的地址为：0063F804
两者一致！
</code></pre>
<p>这么看，应该是实锤了。那么数组后面的元素也就是依次往后放置，有兴趣的也可以自己写代码尝试把它们输出看看。</p>
<h2 id="指向数组的指针">指向数组的指针</h2>
<p>刚刚我们验证了数组的地址就是数组第一个元素的地址。那么指向数组的指针自然也就有两种定义的方法：</p>
<pre><code class="language-c">...
char* p;
//方法1
p = a;
//方法2
p = &amp;a[0];
</code></pre>
<h2 id="指针的运算">指针的运算</h2>
<p>当指针指向数组元素的时候，可以对指针变量进行<strong>加减</strong>运算，<code>+n</code>表示指向p指针所指向的元素的<strong>下一个元素</strong>，<code>-n</code>表示指向p指针所指向的元素的<strong>上一个元素</strong>。并不是将地址加1。</p>
<p>如：</p>
<pre><code class="language-c">//Example 04
#include &lt;stdio.h&gt;
int main(void)
{
    int a[] = { 1,2,3,4,5 };
    int* p = a;
    printf(&quot;*p = %d, *(p+1) = %d, *(p+2) = %d\n&quot;, *p, *(p + 1), *(p + 2));
    printf(&quot;*p -&gt; %p, *(p+1) -&gt; %p, *(p+2) -&gt; %p\n&quot;, p, p + 1, p + 2);
    return 0;
}
</code></pre>
<p>执行结果如下：</p>
<pre><code>//Consequence 04
*p = 1, *(p+1) = 2, *(p+2) = 3
*p -&gt; 00AFF838, *(p+1) -&gt; 00AFF83C, *(p+2) -&gt; 00AFF840
</code></pre>
<p>有的小伙伴可能会想，编译器是怎么知道访问下一个元素而不是地址直接加1呢？</p>
<p>其实就在我们定义指针变量的时候，就已经告诉编译器了。如果我们定义的是整型数组的指针，那么指针加1，实际上就是加上一个<code>sizeof(int)</code>的距离。相对于标准的下标访问，使用指针来间接访问数组元素的方法叫做<code>指针法</code>。</p>
<p>其实使用指针法来访问数组的元素，不一定需要定义一个指向数组的单独的指针变量，因为数组名自身就是指向数组<strong>第一个元素</strong>的指针，因此指针法可以直接作用于数组名：</p>
<pre><code class="language-c">...
printf(&quot;p -&gt; %p, p+1 -&gt; %p, p+2 -&gt; %p\n&quot;, a, a+1, a+2);
printf(&quot;a = %d, a+1 = %d, a+2 = %d&quot;, *a, *(a+1), *(a+2));
...
</code></pre>
<p>执行结果如下：</p>
<pre><code class="language-c">p -&gt; 00AFF838, p+1 -&gt; 00AFF83C, p+2 -&gt; 00AFF840
b = 1, b+1 = 2, b+2 = 3
</code></pre>
<p>现在你是不是感觉，数组和指针有点像了呢？不过笔者先提醒，数组和指针虽然非常像，但是绝对<strong>不是</strong>       一种东西。</p>
<p>甚至你还可以直接用指针来定义字符串，然后用下标法来读取每一个元素：</p>
<pre><code class="language-c">//Example 05
//代码来源于网络
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
int main(void)
{
    char* str = &quot;I love TechZone!&quot;;
    int i, length;
    
    length = strlen(str);
    
    for (i = 0; i &lt; length, i++)
    {
        printf(&quot;%c&quot;, str[i]);
    }
    printf(&quot;\n&quot;);
    
    return 0;
}
</code></pre>
<p>程序运行如下：</p>
<pre><code>//Consequence 05
I love TechZone!
</code></pre>
<p>在刚刚的代码里面，我们定义了一个<strong>字符指针</strong>变量，并且初始化成指向一个字符串。后来的操作，不仅在它身上可以使用<strong>字符串处理函数</strong>，还可以用<strong>下标法</strong>访问字符串中的每一个字符。</p>
<p>当然，循环部分这样写也是没毛病的：</p>
<pre><code class="language-c">...
for (i = 0, i &lt; length, i++)
{
    printf(&quot;%c&quot;, *(str + i));
}
</code></pre>
<p>这就相当于利用了指针法来读取。</p>
<h2 id="指针和数组的区别">指针和数组的区别</h2>
<p>刚刚说了许多指针和数组相互替换的例子，可能有的小伙伴又开始说：“这俩货不就是一个东西吗？”</p>
<p>随着你对指针和数组越来越了解，你会发现，C语言的创始人不会这么无聊去创建两种一样的东西，还叫上不同的名字。指针和数组终究是<strong>不一样</strong>的。</p>
<p>比如笔者之前看过的一个例子：</p>
<pre><code class="language-c">//Example 06
//代码来源于网络
#include &lt;stdio.h&gt;
int main(void)
{
    char str[] = &quot;I love TechZone!&quot;;
    int count = 0;
    
    while (*str++ != '\0')
    {
        count++;
    }
    printf(&quot;总共有%d个字符。\n&quot;, count);
    
    return 0;
}
</code></pre>
<p>当编译器报错的时候，你可能会开始怀疑你学了假的C语言语法：</p>
<pre><code>//Error in Example 06
错误(活动)	E0137	表达式必须是可修改的左值
错误	C2105	“++”需要左值
</code></pre>
<p>我们知道，<code>*str++ != ‘\0’</code>是一个复合表达式，那么就要遵循<strong>运算符优先级</strong>来看。具体可以回顾<a href="http://www.techzone.ltd/post/COperatorASCII/">《C语言运算符优先级及ASCII对照表》</a>。</p>
<p><code>str++</code>比<code>*str</code>的优先级<strong>更高</strong>，但是自增运算符要在<strong>下一条语句</strong>的时候才能生效。所以这个语句的理解就是，先取出<code>str</code>所指向的值，判断是否为<code>\0</code>，若是，则跳出循环，然后<code>str</code>指向下一个字符的位置。</p>
<p>看上去貌似没啥毛病，但是，看看编译器告诉我们的东西：<code>表达式必须是可修改的左值</code></p>
<p><code>++</code>的操作对象是<code>str</code>，那么<code>str</code>到底是不是<strong>左值</strong>呢？</p>
<p>如果是左值的话，那么就必须满足左值的条件。</p>
<blockquote>
<ol>
<li>拥有用于识别和定位一个存储位置的标识符</li>
<li>存储值可修改</li>
</ol>
</blockquote>
<p>第一点，数组名<code>str</code>是可以满足的，因为数组名实际上就是定位数组第一个元素的位置。但是第二点就不满足了，数组名实际上是一个地址，地址是<strong>不可以</strong>修改的，它是一个常量。如果非要利用上面的思路来实现的话，可以将代码改成这样：</p>
<pre><code class="language-c">//Example 06 V2
//代码来源于网络
#include &lt;stdio.h&gt;
int main(void)
{
    char str[] = &quot;I love TechZone!&quot;;
    char* target = str;
    int count = 0;
    
    while (*target++ != '\0')
    {
        count++;
    }
    printf(&quot;总共有%d个字符。\n&quot;, count);
    
    return 0;
}
</code></pre>
<p>这样就可以正常执行了：</p>
<pre><code>//Consequence 06 V2
总共有16个字符。
</code></pre>
<p>这样我们就可以得出：数组名只是一个<strong>地址</strong>，而指针是一个<strong>左值</strong>。</p>
<h2 id="指针数组数组指针">指针数组？数组指针？</h2>
<p>看下面的例子，你能分辨出哪个是指针数组，哪个是数组指针吗？</p>
<pre><code class="language-c">int* p1[5];
int(*p2)[5];
</code></pre>
<p>单个的我们都可以判断，但是组合起来就有些难度了。</p>
<p>答案：</p>
<pre><code class="language-c">int* p1[5];//指针数组
int(*p2)[5];//数组指针
</code></pre>
<p>我们挨个来分析。</p>
<h3 id="指针数组">指针数组</h3>
<p>数组下标<code>[]</code>的优先级是最高的，因此<code>p1</code>是一个有5个元素的<strong>数组</strong>。那么这个数组的类型是什么呢？答案就是<code>int*</code>，是<strong>指向整型变量的指针</strong>。因此这是一个<strong>指针数组</strong>。</p>
<p>那么这样的数组应该怎么样去初始化呢？</p>
<p>你可以定义5个变量，然后挨个取地址来初始化。</p>
<p>不过这样太繁琐了，但是，并不是说指针数组就没什么用。</p>
<p>比如：</p>
<pre><code class="language-c">//Example 07
#include &lt;stdio.h&gt;
int main(void)
{
    char* p1[5] = {
        &quot;人生苦短，我用Python。&quot;,
        &quot;PHP是世界上最好的语言！&quot;,
        &quot;One more thing...&quot;,
        &quot;一个好的程序员应该是那种过单行线都要往两边看的人。&quot;,
        &quot;C语言很容易让你犯错误；C++看起来好一些，但当你用它时，你会发现会死的更惨。&quot;
    };
    int i;
    for (i = 0; i &lt; 5; i++)
    {
        printf(&quot;%s\n&quot;, p1[i]);
    }
    return 0;
}
</code></pre>
<p>结果如下：</p>
<pre><code>//Consequence 07
人生苦短，我用Python。
PHP是世界上最好的语言！
One more thing...
一个好的程序员应该是那种过单行线都要往两边看的人。
C语言很容易让你犯错误；C++看起来好一些，但当你用它时，你会发现会死的更惨。
</code></pre>
<p>这样是不是比二维数组来的更加直接更加通俗呢？</p>
<h3 id="数组指针">数组指针</h3>
<p><code>()</code>和<code>[]</code>在优先级里面属于<strong>同级</strong>，那么就按照<strong>先后顺序</strong>进行。</p>
<p><code>int(*p2)</code>将<code>p2</code>定义为<strong>指针</strong>， 后面跟随着一个5个元素的<strong>数组</strong>，<code>p2</code>就指向这个数组。因此，数组指针是一个<strong>指针</strong>，它指向的是一个数组。</p>
<p>但是，如果想对数组指针初始化的时候，千万要小心，比如：</p>
<pre><code class="language-c">//Example 08
#include &lt;stdio.h&gt;
int main(void)
{
    int(*p2)[5] = {1, 2, 3, 4, 5};
    int i;
    for (i = 0; i &lt; 5; i++)
    {
        printf(&quot;%d\n&quot;, *(p2 + i));
    }
    return 0;
}
</code></pre>
<p>Visual Studio 2019报出以下的错误：</p>
<pre><code>//Error and Warning in Example 08
错误(活动)	E0146	初始值设定项值太多
错误	C2440	“初始化”: 无法从“initializer list”转换为“int (*)[5]”
警告	C4477	“printf”: 格式字符串“%d”需要类型“int”的参数，但可变参数 1 拥有了类型“int *”
</code></pre>
<p>这其实是一个非常典型的错误使用指针的案例，编译器提示说这里有一个<strong>整数</strong>赋值给<strong>指针变量</strong>的问题，因为<code>p2</code>归根结底还是指针，所以应该给它传递一个<strong>地址</strong>才行，更改一下：</p>
<pre><code class="language-c">//Example 08 V2
#include &lt;stdio.h&gt;
int main(void)
{
    int temp[5] = {1, 2, 3, 4, 5};
    int(*p2)[5] = temp;
    int i;
    for (i = 0; i &lt; 5; i++)
    {
        printf(&quot;%d\n&quot;, *(p2 + i));
    }
    return 0;
}
</code></pre>
<pre><code>//Error and Warning in Example 08 V2
错误(活动)	E0144	&quot;int *&quot; 类型的值不能用于初始化 &quot;int (*)[5]&quot; 类型的实体
错误	C2440	“初始化”: 无法从“int [5]”转换为“int (*)[5]”
警告	C4477	“printf”: 格式字符串“%d”需要类型“int”的参数，但可变参数 1 拥有了类型“int *”
</code></pre>
<p>可是怎么还是有问题呢？</p>
<p>我们回顾一下，指针是如何指向数组的。</p>
<pre><code class="language-c">int temp[5] = {1, 2, 3, 4, 5};
int* p = temp;
</code></pre>
<p>我们原本以为，指针<code>p</code>是指向数组的指针，但是实际上<strong>并不是</strong>。仔细想想就会发现，这个指针实际上是指向的数组的<strong>第一个元素</strong>，而不是指向数组。因为数组里面的元素在内存中都是挨着个儿存放的，因此只需要知道第一个元素的地址，就可以访问到后面的所有元素。</p>
<p>但是，这么来看的话，指针<code>p</code>指向的就是一个<strong>整型变量</strong>的指针，并不是指向<strong>数组</strong>的指针。而刚刚我们用的数组指针，才是指向数组的指针。因此，应该将<strong>数组的地址</strong>传递给数组指针，而不是将第一个元素的地址传入，尽管它们值相同，但是<strong>含义</strong>确实不一样：</p>
<pre><code class="language-c">//Example 08 V3
//Example 08 V2
#include &lt;stdio.h&gt;
int main(void)
{
    int temp[5] = {1, 2, 3, 4, 5};
    int(*p2)[5] = &amp;temp;//此处取地址
    int i;
    for (i = 0; i &lt; 5; i++)
    {
        printf(&quot;%d\n&quot;, *(*p2 + i));
    }
    return 0;
}
</code></pre>
<p>程序运行如下：</p>
<pre><code>//Consequence 08
1
2
3
4
5
</code></pre>
<h2 id="指针和二维数组">指针和二维数组</h2>
<p>在上一节<a href="http://www.techzone.ltd/post/CArray/">《C语言之数组》</a>我们讲过<strong>二维数组</strong>的概念，并且我们也知道，C语言的二维数组其实在内存中也是<strong>线性存放</strong>的。</p>
<p>假设我们定义了：<code>int array[4][5]</code></p>
<h3 id="array">array</h3>
<p>array作为数组的名称，显然应该表示的是数组的<strong>首地址</strong>。由于二维数组实际上就是一维数组的<strong>线性拓展</strong>，因此array应该就是指的<code>指向包含5个元素的数组的指针</code>。</p>
<p>如果你用<code>sizeof()</code>去测试<code>array</code>和<code>array+1</code>的话，就可以测试出来这样的结论。</p>
<h3 id="array1">*(array+1)</h3>
<p>首先从刚刚的问题我们可以得出，<code>array+1</code>同样也是指的<code>指向包含5个元素的数组的指针</code>，因此<code>*(array+1)</code>就是相当于<code>array[1]</code>，而这刚好相当于<code>array[1][0]</code>的数组名。因此<code>*(array+1)</code>就是指第二行子数组的第一个元素的地址。</p>
<h3 id="array12">*(*(array+1)+2)</h3>
<p>有了刚刚的结论，我们就不难推理出，这个实际上就是<code>array[1][2]</code>。是不是感觉非常简单呢？</p>
<p>总结一下，就是下面的这些结论，记住就好，理解那当然更好：</p>
<pre><code class="language-c">*(array + i) == array[i]
*(*(array + i) + j) == array[i][j]
*(*(*(array + i) + j) + k) == array[i][j][k]
...
</code></pre>
<h2 id="数组指针和二维数组">数组指针和二维数组</h2>
<p>我们在上一节里面讲过，在初始化二维数组的时候是可以偷懒的：</p>
<pre><code class="language-C">int array[][3] = {
    {1, 2, 3},
    {4, 5, 6}
};
</code></pre>
<p>刚刚我们又说过，定义一个数组指针是这样的：</p>
<pre><code class="language-c">int(*p)[3];
</code></pre>
<p>那么组合起来是什么意思呢？</p>
<pre><code class="language-c">int(*p)[3] = array;
</code></pre>
<p>通过刚刚的说明，我们可以知道，<code>array</code>是指向一个3个元素的数组的<strong>指针</strong>，所以这里完全可以将<code>array</code>的值赋值给<code>p</code>。</p>
<p>其实C语言的指针非常灵活，同样的代码用不同的角度去解读，就可以有不同的应用。</p>
<p>那么如何使用指针来访问二维数组呢？没错，就是使用<strong>数组指针</strong>：</p>
<pre><code class="language-c">//Example 09
#include &lt;stdio.h&gt;
int main(void)
{
    int array[3][4] = {
        {0, 1, 2, 3},
        {4, 5, 6, 7},
        {8, 9, 10, 11}
    };
    int(*p)[4];
    int i, j;
    p = array;
    for (i = 0, i &lt; 3, i++)
    {
        for (j = 0, j &lt; 4, j++)
        {
            printf(&quot;%2d &quot;, *(*(p+i) + j)); 
        }
        printf(&quot;\n&quot;);
    }
    return 0;
}
</code></pre>
<p>运行结果：</p>
<pre><code>//Consequence 09
0 1 2 3 
4 5 6 7 
8 9 10 11 
</code></pre>
<h1 id="void指针">void指针</h1>
<p><code>void</code>实际上是<code>无类型</code>的意思。如果你尝试用它来定义一个变量，编译器肯定会<strong>报错</strong>，因为不同类型所占用的内存有可能<strong>不一样</strong>。但是如果定义的是一个指针，那就没问题。<code>void</code>类型中指针可以指向<strong>任何一个类型</strong>的数据，也就是说，任何类型的指针都可以赋值给<code>void</code>指针。</p>
<p>将任何类型的指针转换为<code>void</code>是没有问题的。但是如果你要反过来，那就需要<strong>强制类型转换</strong>。此外，不要对<code>void</code>指针<strong>直接解引用</strong>，因为编译器其实并不知道<code>void</code>指针会存放什么样的类型。</p>
<pre><code class="language-c">//Example 10
#include &lt;stdio.h&gt;
int main(void)
{
    int num = 1024;
    int* pi = &amp;num;
    char* ps = &quot;TechZone&quot;;
    void* pv;
    
    pv = pi;
    printf(&quot;pi:%p,pv:%p\n&quot;, pi, pv);
    printf(&quot;*pv:%d\n&quot;, *pv);
    
    pv = ps;
    printf(&quot;ps:%p,pv:%p\n&quot;, ps, pv);
    printf(&quot;*pv:%s\n&quot;, *pv);
}
</code></pre>
<p>这样会报错：</p>
<pre><code>//Error in Example 10
错误	C2100	非法的间接寻址
错误	C2100	非法的间接寻址
</code></pre>
<p>如果一定要这么做，那么可以用<strong>强制类型转换</strong>：</p>
<pre><code class="language-c">//Example 10 V2
#include &lt;stdio.h&gt;
int main(void)
{
    int num = 1024;
    int* pi = &amp;num;
    char* ps = &quot;TechZone&quot;;
    void* pv;

    pv = pi;
    printf(&quot;pi:%p,pv:%p\n&quot;, pi, pv);
    printf(&quot;*pv:%d\n&quot;, *(int*)pv);

    pv = ps;
    printf(&quot;ps:%p,pv:%p\n&quot;, ps, pv);
    printf(&quot;*pv:%s\n&quot;, pv);
}
</code></pre>
<p>当然，使用void指针一定要小心，由于void指针几乎可以<strong>通吃</strong>所有类型，所以间接使得不同类型的指针转换变得合法，如果代码中存在不合理的转换，编译器也不会报错。</p>
<p>因此，void指针能不用则不用，后面讲函数的时候，还可以解锁更多新的玩法。</p>
<h1 id="null指针">NULL指针</h1>
<p>在C语言中，如果一个指针不指向任何数据，那么就称之为<strong>空指针</strong>，用<strong>NULL</strong>来表示。NULL其实是一个宏定义：</p>
<pre><code class="language-c">#define NULL ((void *)0)
</code></pre>
<p>在大部分的操作系统中，地址0通常是一个<strong>不被使用</strong>的地址，所以如果一个指针指向NULL，就意味着不指向任何东西。为什么一个指针要指向NULL呢？</p>
<p>其实这反而是一种比较指的推荐的<strong>编程风格</strong>——当你暂时还不知道该指向哪儿的时候，就让它指向NULL，以后不会有太多的麻烦，比如：</p>
<pre><code class="language-c">//Example 11
#include &lt;stdio.h&gt;
int main(void)
{
    int* p1;
    int* p2 = NULL;
    printf(&quot;%d\n&quot;, *p1);
    printf(&quot;%d\n&quot;, *p2);
    return 0;
}
</code></pre>
<p>第一个指针未被初始化。在有的编译器里面，这样未初始化的变量就会被赋予<strong>随机值</strong>。这样指针被称为<strong>迷途指针</strong>，<strong>野指针</strong>或者<strong>悬空指针</strong>。如果后面的代码对这类指针解引用，而这个地址又刚好是合法的话，那么就会产生莫名其妙的结果，甚至导致程序的崩溃。因此养成良好的习惯，在暂时不清楚的情况下使用NULL，可以节省大量的后期调试的时间。</p>
<h1 id="指向指针的指针">指向指针的指针</h1>
<p>开始套娃了。其实只要你理解了指针的概念，也就没什么大不了的。</p>
<pre><code class="language-c">//Example 12
#include &lt;stdio.h&gt;
int main(void)
{
    int num = 1;
    int* p = &amp;num;
    int** pp = &amp;p;
    
    printf(&quot;num: %d\n&quot;, num);
    printf(&quot;*p: %d\n&quot;, *p);
    printf(&quot;**p: %d\n&quot;, **pp);
    printf(&quot;&amp;p: %p, pp: %p\n&quot;, &amp;p, pp);
    printf(&quot;&amp;num: %p, p: %p, *pp: %p\n&quot;, &amp;num, p, *pp);
    return 0;
}
</code></pre>
<p>程序结果如下：</p>
<pre><code>//Consequence 12
num: 1
*p: 1
**p: 1
&amp;p: 004FF960, pp: 004FF960
&amp;num: 004FF96C, p: 004FF96C, *pp: 004FF96C
</code></pre>
<p>当然你也可以无限地套娃，一直指下去。不过这样会让代码可读性变得<strong>很差</strong>，过段时间可能你自己都看不懂你写的代码了。</p>
<h1 id="指针数组和指向指针的指针">指针数组和指向指针的指针</h1>
<p>那么，指向指针的指针有什么用呢？</p>
<p>它可不是为了去创造混乱代码，在一个经典的实例里面，就可以体会到它的用处：</p>
<pre><code class="language-c">char* Books[] = {
    &quot;《C专家编程》&quot;,
    &quot;《C和指针》&quot;,
    &quot;《C的陷阱与缺陷》&quot;,
    &quot;《C Primer Plus》&quot;,
    &quot;《Python基础教程（第三版）》&quot;
};
</code></pre>
<p>然后我们需要将这些书进行分类。我们发现，其中有一本是写Python的，其他都是C语言的。这时候指向指针的指针就派上用场了。首先，我们刚刚定义了一个指针数组，也就是说，里面的所有元素的类型<strong>都是指针</strong>，而数组名却又可以用指针的形式来<strong>访问</strong>，因此就可以使用<strong>指向指针的指针</strong>来指向指针数组：</p>
<pre><code class="language-c">...
char** Python;
char** CLang[4];

Python = &amp;Books[5];
CLang[0] = &amp;Books[0];
CLang[1] = &amp;Books[1];
CLang[2] = &amp;Books[2];
CLang[3] = &amp;Books[3];
...
</code></pre>
<p>因为字符串的取地址值实际上就是其<strong>首地址</strong>，也就是一个<strong>指向字符指针的指针</strong>，所以可以这样赋值。</p>
<p>这样，我们就利用指向指针的指针完成了对书籍的分类，这样既避免了浪费多余的内存，而且当其中的书名要修改，只需要改一次即可，代码的灵活性和安全性都得到了提升。</p>
<h1 id="常量和指针">常量和指针</h1>
<p>常量，在我们目前的认知里面，应该是这样的：</p>
<pre><code>520, 'a'
</code></pre>
<p>或者是这样的：</p>
<pre><code class="language-c">#define MAX 1000
#define B 'b'
</code></pre>
<p>常量和变量最大的区别，就是前者<strong>不能够被修改</strong>，后者可以。那么在C语言中，可以将变量变成像具有常量一样的特性，利用<code>const</code>即可。</p>
<pre><code class="language-c">const int max = 1000;
const char a = 'a';
</code></pre>
<p>在<code>const</code>关键字的作用下，变量就会<strong>失去</strong>本来具有的可修改的特性，变成“只读”的属性。</p>
<h1 id="指向常量的指针">指向常量的指针</h1>
<p>强大的指针当然也是可以指向被<code>const</code>修饰过的变量，但这就意味着<strong>不能通过</strong>指针来修改它所引用的值。总结一下，就是以下4点：</p>
<blockquote>
<ol>
<li>指针可以修改为指向不同的变量</li>
<li>指针可以修改为指向不同的常量</li>
<li>可以通过解引用来读取指针指向的数据</li>
<li>不可以通过解引用来修改指针指向的数据</li>
</ol>
</blockquote>
<h1 id="常量指针">常量指针</h1>
<h2 id="指向非常量的常量指针">指向非常量的常量指针</h2>
<p>指针本身作为一种<strong>变量</strong>，也是可以修改的。因此，指针也是可以被<code>const</code>修饰的，只不过位置稍稍<strong>发生了点变化</strong>：</p>
<pre><code class="language-c">...
int* const p = &amp;num;
...
</code></pre>
<p>这样的指针有如下的特性：</p>
<blockquote>
<ol>
<li>指针自身不能够被修改</li>
<li>指针指向的值可以被修改</li>
</ol>
</blockquote>
<h2 id="指向常量的常量指针">指向常量的常量指针</h2>
<p>在定义普通变量的时候也用<code>const</code>修饰，就得到了这样的指针。不过由于限制太多，一般很少用到：</p>
<pre><code class="language-c">...
int num = 100;
const int cnum = 200;
const int* const p = &amp;cnum;
...
</code></pre>
<hr>
<p>这期博客就到此结束了，没学会的反复咀嚼，学会了的自己去实战，相信你的C语言编程能力会越来越强。</p>

              </div>
              <div class="post-footer">
  <ul class="post-copyright">
    <li class="post-copyright-author">
      <strong>本文作者：</strong>
      Madara
    </li>
    <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://hsxyhao.github.io/post/ce-shi" title="测试">测试</a>
    </li>
    <li class="post-copyright-license">
      <strong>版权声明： </strong>
      本博客所有文章除特别声明外，转载请注明出处！
    </li>
  </ul>
  <div class="tags">
    
  </div>
  <div class="nav">
    <div class="nav-prev">
      
    </div>
    <div class="nav-next">
      
        <a class="nav-pc-next" href="https://hsxyhao.github.io/post/gridea_help">关于Gridea的远程连接、同步失败问题</a>
        <a class="nav-mobile-next" href="https://hsxyhao.github.io/post/gridea_help">下一篇</a>
        <i class="fa fa-chevron-right"></i>
      
    </div>
  </div>
</div>
              
                
                  <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script>
  var gitalk = new Gitalk({
    clientID: '7daf0c9da2ee9a72ecba',
    clientSecret: '39e3424bd496a5d8dcdbb618c370897256810975',
    repo: 'hsxyhao.github.io',
    owner: 'hsxyhao',
    admin: ['hsxyhao'],
    id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })
  gitalk.render('gitalk-container')
</script>
                
                
              
            </div>
          </div>
        </div>
      </div>
      <div class="footer-box">
  <footer class="footer">
    <div class="copyright">
      © 2019-2020 <i class="fa fa-heart"></i> HsxyHao
    </div>
    <div class="poweredby">
      <div class="power-left">Power By<a href="https://github.com/hsxyhao"> HsxyHao</a></div>
      <div>Copy From<a href="https://github.com/iissnan/hexo-theme-next"> Hexo Next Theme</a></div>
    </div>
  </footer>
  
  
  <div class="gemini back-to-top" id="back_to_top">
    <i class="fa fa-arrow-up"></i>
    
    <span class="scrollpercent">
      <span id="back_to_top_text">0</span>%
    </span>
    
  </div>
  
    <div class="bg-img">
      <img src="/media/images/custom-bgImg.jpg" />
    </div>
  
</div>

<script>

  let sideBarOpen = 'sidebar-open';
  let body = document.body;
  let back2Top = document.querySelector('#back_to_top'),
  back2TopText = document.querySelector('#back_to_top_text'),
  drawerBox = document.querySelector('#drawer_box'),
  rightSideBar = document.querySelector('.sidebar'),
  viewport = document.querySelector('body');

  function scrollAnimation(currentY, targetY) {
   
    let needScrollTop = targetY - currentY
    let _currentY = currentY
    setTimeout(() => {
      const dist = Math.ceil(needScrollTop / 10)
      _currentY += dist
      window.scrollTo(_currentY, currentY)
      if (needScrollTop > 10 || needScrollTop < -10) {
        scrollAnimation(_currentY, targetY)
      } else {
        window.scrollTo(_currentY, targetY)
      }
    }, 1)
  }

  back2Top.addEventListener("click", function(e) {
    scrollAnimation(body.scrollTop, 0);
    e.stopPropagation();
    return false;
  });
  
  window.addEventListener('scroll', function(e) {
    let percent = body.scrollTop / (body.scrollHeight - body.clientHeight) * 100;
    if (percent > 1 && !back2Top.classList.contains('back-top-active')) {
      back2Top.classList.add('back-top-active');
    }
    if (percent == 0) {
      back2Top.classList.remove('back-top-active');
    }
    if (back2TopText) {
      back2TopText.textContent = Math.floor(percent);
    }
  });

  // 动态调整站点概览高度
  if (back2Top.classList.contains('pisces') || back2Top.classList.contains('gemini')) {
    let sideBar = document.querySelector('.sidebar');
    let navUl = document.querySelector('#nav_ul');
    sideBar.style = 'margin-top:' + (navUl.children.length * 42 + 162) + 'px;';
  }
  
  let open = false, MOTION_TIME = 300, RIGHT_MOVE_DIS = '320px';

  if (drawerBox) {
    let rightMotions = document.querySelectorAll('.right-motion');
    drawerBox.onclick = function() {
      open = !open;
      window.Velocity(rightSideBar, 'stop');
      window.Velocity(viewport, 'stop');
      if (open) {
        window.Velocity(rightSideBar, {
          width: RIGHT_MOVE_DIS
        }, {
          duration: MOTION_TIME,
          begin: function() {
            console.log(rightMotions)
            window.Velocity(rightMotions, 'transition.slideRightIn',{
            });
          }
        })
        window.Velocity(viewport, {
          paddingRight: RIGHT_MOVE_DIS
        } ,{
          duration: MOTION_TIME
        });
      } else {
        window.Velocity(rightSideBar, {
          width: '0px'
        }, {
          duration: MOTION_TIME,
          begin: function() {
            window.Velocity(rightMotions, {
              opacity: 0
            });
          }
        })
        window.Velocity(viewport, {
          paddingRight: '0px'
        } ,{
          duration: MOTION_TIME
        });
      }
      for (let i = 0; i < drawerBox.children.length; i++) {
        drawerBox.children[i].classList.toggle('muse-line');
      }
      drawerBox.classList.toggle(sideBarOpen);
    }
  }

  // 代码高亮
  hljs.initHighlightingOnLoad();
</script>
    </div>
  </body>
  <script src="/media/js/motion.js"></script>
</html>