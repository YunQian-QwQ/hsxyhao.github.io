<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<meta name="keywords" content="Java | 个人博客 | Gridea | NexT | next">
<meta name="description" content="Gridea Next | 懂点前端的后端 | 中间件 | Java">
<meta name="theme-color" content="#222">
<title>NexT-TechZone | Madara</title>
<link rel="shortcut icon" href="https://yeming.site/favicon.ico?v=1583308929898">
<link rel="stylesheet" href="https://yeming.site/styles/main.css">

<link rel="stylesheet" href="/media/css/gemini.css">

<link rel="stylesheet" href="/media/fonts/font-awesome.css">
<link href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Rosario:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">

<link href="/media/hljs/styles/default.css" rel="stylesheet">  

<script src="/media/hljs/highlight.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.ui.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css" integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js" integrity="sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js" integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"
    onload="renderMathInElement(document.body);"></script>

    <meta name="description" content="NexT-TechZone" />
    <meta name="keywords" content="" />
  </head>
  <body>
    <div class="head-top-line"></div>
    <div class="header-box">
      
<div class=" gemini">
  <header class="header bg-color ">
    <div class="blog-header box-shadow-wrapper bg-color " id="header">
      <div class="nav-toggle" id="nav_toggle">
        <div class="toggle-box">
          <div class="line line-top"></div>
          <div class="line line-center"></div>
          <div class="line line-bottom"></div>
        </div>
      </div>
      <div class="site-meta">       
        <div class="site-title">
          
            <a href="/" class="brand">
              <span>Madara</span>
            </a>  
          
        </div>
        
          <p class="subtitle">精于心，简于形</p>
        
      </div>
      <nav class="site-nav" id="site_nav">
        <ul id="nav_ul">
          
            <li class="nav-item ">
              
                <a href="/">
                  <i class="fa fa-home"></i> 首页
                </a>
              
            </li>
          
            <li class="nav-item ">
              
                <a href="/archives">
                  <i class="fa fa-archive"></i> 归档
                </a>
              
            </li>
          
            <li class="nav-item ">
              
                <a href="/tags">
                  <i class="fa fa-tags"></i> 标签
                </a>
              
            </li>
          
            <li class="nav-item ">
              
                <a href="/post/about">
                  <i class="fa fa-user"></i> 关于
                </a>
              
            </li>
          
          <li class="nav-item">
            <a>
              <i class="fa fa-search"></i> 搜索
            </a>
          </li>
        </ul>
      </nav>
    </div>
  </header>
</div>

<script type="text/javascript"> 
 
  let showNav = true;

  let navToggle = document.querySelector('#nav_toggle'),
  siteNav = document.querySelector('#site_nav');
  
  function navClick() {
    let sideBar = document.querySelector('.sidebar');
    let navUl = document.querySelector('#nav_ul');
    navToggle.classList.toggle('nav-toggle-active');
    siteNav.classList.toggle('nav-menu-active');
    if (siteNav.classList.contains('nav-menu-active')) {
      siteNav.style = "height: " + (navUl.children.length * 42) +"px !important";
    } else {
      siteNav.style = "";
    }
  }

  navToggle.addEventListener('click',navClick);  
</script>
    </div>
    <div class="main-continer">
      
      <div class="section-layout gemini ">
        <div class="section-layout-wrapper">
          

<div class="sidebar">
  
    <div class="sidebar-box box-shadow-wrapper bg-color right-motion" id="sidebar">
      
      <div class="sidebar-body gemini" id="sidebar_body">
        
          
            <div style="opacity: 1;">
              <div class="toc-box right-motion">
  <div class="toc-wrapper auto-number no_compress" id="toc_wrapper">
    <ul class="markdownIt-TOC">
<li><a href="#%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E5%92%8C%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F">局部变量和全局变量</a>
<ul>
<li><a href="#%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F">局部变量</a></li>
<li><a href="#%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F">全局变量</a></li>
</ul>
</li>
<li><a href="#%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E9%93%BE%E6%8E%A5%E5%B1%9E%E6%80%A7">作用域和链接属性</a>
<ul>
<li><a href="#%E4%BB%A3%E7%A0%81%E5%9D%97%E4%BD%9C%E7%94%A8%E5%9F%9F">代码块作用域</a></li>
<li><a href="#%E6%96%87%E4%BB%B6%E4%BD%9C%E7%94%A8%E5%9F%9F">文件作用域</a></li>
<li><a href="#%E5%8E%9F%E5%9E%8B%E4%BD%9C%E7%94%A8%E5%9F%9F">原型作用域</a></li>
<li><a href="#%E5%87%BD%E6%95%B0%E4%BD%9C%E7%94%A8%E5%9F%9F">函数作用域</a></li>
<li><a href="#%E9%93%BE%E6%8E%A5%E5%B1%9E%E6%80%A7">链接属性</a></li>
</ul>
</li>
<li><a href="#%E7%94%9F%E5%AD%98%E6%9C%9F%E5%92%8C%E5%AD%98%E5%82%A8%E7%B1%BB%E5%9E%8B">生存期和存储类型</a>
<ul>
<li><a href="#%E7%94%9F%E5%AD%98%E6%9C%9F">生存期</a></li>
<li><a href="#%E5%AD%98%E5%82%A8%E7%B1%BB%E5%9E%8B">存储类型</a>
<ul>
<li><a href="#1-%E8%87%AA%E5%8A%A8%E5%8F%98%E9%87%8F">1. 自动变量</a></li>
<li><a href="#2-%E5%AF%84%E5%AD%98%E5%99%A8%E5%8F%98%E9%87%8F">2. 寄存器变量</a></li>
<li><a href="#3-%E9%9D%99%E6%80%81%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F">3. 静态局部变量</a></li>
<li><a href="#4-extern">4.  extern</a></li>
<li><a href="#5-typedef">5.  typedef</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E9%80%92%E5%BD%92">递归</a>
<ul>
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%80%92%E5%BD%92">什么是递归</a></li>
<li><a href="#%E9%80%92%E5%BD%92%E6%B1%82%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97">递归求斐波那契数列</a></li>
<li><a href="#%E9%80%92%E5%BD%92%E6%B1%82%E6%B1%89%E8%AF%BA%E5%A1%94">递归求汉诺塔</a></li>
<li><a href="#%E5%88%86%E6%B2%BB%E6%B3%95">分治法</a></li>
</ul>
</li>
</ul>

  </div>
</div>

<script>

let lastTop = 0, lList = [], hList = [], postBody, lastIndex = -1; 
let active = 'active-show', activeClass = 'active-current';
let tocWrapper = document.querySelector('#toc_wrapper');
let tocContent = tocWrapper.children[0];
let autoNumber = tocWrapper&&tocWrapper.classList.contains('auto-number');

function addTocNumber(elem, deep) {
  if (!elem) {
    return;
  }
  let prop = elem.__proto__;

  if (prop === HTMLUListElement.prototype) {
    for (let i = 0; i < elem.children.length; i++) {
      addTocNumber(elem.children[i], deep + (i + 1) + '.');
    }
  } else if (prop === HTMLLIElement.prototype) {
    // 保存li元素
    lList.push(elem);
    for (let i = 0; i < elem.children.length; i++) {
      let cur = elem.children[i];
      if (cur.__proto__ === HTMLAnchorElement.prototype) {
        if (autoNumber) {
          cur.text =  deep + ' ' + cur.text;
        }
      } else if (cur.__proto__ === HTMLUListElement.prototype) {
        addTocNumber(cur, deep);
      }
    }
  }
}


document.addEventListener('scroll', function(e) {
  if (lList.length <= 0) {
    return;
  }
  let scrollTop = document.scrollingElement.scrollTop;
  let dir;

  if (lastTop - scrollTop > 0) {
    dir = 'up';
  } else {
    dir = 'down';
  }

  lastTop = scrollTop;
  if (scrollTop <= 0) {
    if (lastIndex >= 0 && lastIndex < hList.length) {
      lList[lastIndex].classList.remove(activeClass);
    }
    return;
  }

  let current = 0, hasFind = false;
  for (let i = 0; i < hList.length; i++) {
    if (hList[i].offsetTop > scrollTop) {
      current = i;
      hasFind = true;
      break;
    }
  }
  if (!hasFind && scrollTop > lList[lList.length - 1].offsetTop) {
    current = hList.length - 1;
  } else {
    current--;
  }
  if (dir === 'down') {
    if (current > lastIndex) {
      addActiveClass(current);
      removeActiveClass(lastIndex) 
      lastIndex = current;
      removeParentActiveClass();
      lList[current] && addActiveLiElemment(lList[current].parentElement,tocContent);
    }
  } else {
    if (current < lastIndex) {
      addActiveClass(current);
      removeActiveClass(lastIndex);
      lastIndex = current;
      removeParentActiveClass();
      lList[current] && addActiveLiElemment(lList[current].parentElement,tocContent);
    }
  }
});

function removeParentActiveClass() {
  let parents = tocContent.querySelectorAll('.'+active)
  parents.forEach(function(elem) {
    elem.classList.remove(active);
  });
}

function addActiveClass(index) {
  if (index >= 0 && index < hList.length) {
    lList[index].classList.add(activeClass);
  }
}

function removeActiveClass(index) {
  if (index >= 0 && index < hList.length) {
    lList[index].classList.remove(activeClass);
  }
}

function addActiveLiElemment(elem, parent) {
  if (!elem || elem === parent) {
    return;
  } else {
    if (elem.__proto__ === HTMLLIElement.prototype) {
      elem.classList.add(active);
    }
    addActiveLiElemment(elem.parentElement, parent);
  }
}

function showToc() {
  if (tocWrapper) {
    postBody = document.querySelector('#post_body');
    for (let i = 0; i < postBody.children.length; i++) {
      if (postBody.children[i].__proto__ === HTMLHeadingElement.prototype) {
        hList.push(postBody.children[i]);
      }
    }
    if (tocWrapper.classList.contains('compress')) {
        tocContent.classList.add('closed');
    } else if (tocWrapper.classList.contains('no_compress')){
      tocContent.classList.add('expanded');
    } else {
      if (hList.length > 10) {
        active = 'active-hidden'
        tocContent.classList.add('closed');
      } else {
        tocContent.classList.add('expanded');
      }
    }
  }
}
addTocNumber(tocContent, '');

window.addEventListener('load', function() {
  showToc();
  document.querySelector('#sidebar').style='display: block;';
  tocWrapper.classList.add('toc-active');
  setTimeout(function() {
    if ("createEvent" in document) {
      let evt = document.createEvent("HTMLEvents");
      evt.initEvent("scroll", false, true);
      document.dispatchEvent(evt);
    }
    else {
      document.fireEvent("scroll");
    }
  }, 500)
})

</script>
            </div>
          
        
      </div>
    </div>
  
</div>
<script>
  const SIDEBAR_TITLE_ACTIVE = 'sidebar-title-active';
  const SIDEBAR_BODY_ACTIVE = 'sidebar-body-active';
  const SLIDE_UP_IN = 'slide-up-in';

  let sidebar = document.querySelector('#sidebar'),
  tocSideBar = document.querySelector('#tocSideBar'),
  metaSideBar = document.querySelector('#metaSideBar'),
  postToc = document.querySelector('#post_toc'),
  postSiteMeta = document.querySelector('#post_side_meta'),
  sidebarTitle = document.querySelector('.sidebar-title'),
  sidebarBody = document.querySelector('#sidebar_body');

  tocSideBar && tocSideBar.addEventListener('click', (e) => {
    toggleSidebar(e);
  });

  metaSideBar && metaSideBar.addEventListener('click', (e) => {
    toggleSidebar(e);
  });

  function toggleSidebar(e) {
    let currentTitle = document.querySelector("."+SIDEBAR_TITLE_ACTIVE);
    if (currentTitle == e.srcElement) {
      return ;
    }
    let current, showElement, hideElement;
    if (e.srcElement == metaSideBar) {
      showElement = postSiteMeta;
      hideElement = postToc;
    } else if (e.srcElement == tocSideBar){
      showElement = postToc;
      hideElement = postSiteMeta;
    }
    currentTitle.classList.remove(SIDEBAR_TITLE_ACTIVE);
    e.srcElement.classList.add(SIDEBAR_TITLE_ACTIVE);

    window.Velocity(hideElement, 'stop');
    window.Velocity(hideElement, 'transition.slideUpOut', {
      display: 'none',
      duration: 200,
      complete: function () {
        window.Velocity(showElement, 'transition.slideDownIn', {
          duration: 200
        });
      }
    })
    hideElement.classList.remove(SIDEBAR_BODY_ACTIVE);
    showElement.classList.add(SIDEBAR_BODY_ACTIVE);
  }

  postToc && postToc.addEventListener('transitionend', function() {
    this.classList.remove(SLIDE_UP_IN);
  });

  if (sidebarBody) {
    if (sidebarBody.classList.contains('pisces') || sidebarBody.classList.contains('gemini')) {
      let hasFix = false;
      let scrollEl = document.querySelector('.main-continer');
      let limitTop = document.querySelector('#nav_ul').children.length * 42 + 162;
      window.addEventListener('scroll', function(e) {
        if (document.scrollingElement.scrollTop >= limitTop) {
          if (!hasFix) {
            sidebar.classList.add('sidebar-fixed');
            hasFix = true;
          }
        } else {
          if (hasFix) {
            sidebar.classList.remove('sidebar-fixed');
            hasFix = false;
          }
        }
      });
    }
  }
  
</script>
          <div class="section-box box-shadow-wrapper">
            <div class="section bg-color post post-page">
              <header class="post-header">
  <h1 class="post-title">
    <a class="post-title-link" href="https://yeming.site/post/zVcsib6Ce/">
      NexT-TechZone
    </a>
  </h1>
  <div class="post-meta">
    
    <span class="meta-item pc-show">
      <i class="fa fa-calendar-o"></i>
      <span>发布于</span>
      <span>2020-02-07</span>
      <span class="post-meta-divider pc-show">|</span>
    </span>
    
    <span class="meta-item">
      <i class="fa fa-clock-o"></i>
      <span>19分钟</span>
    </span>
    <span class="meta-item">
      <span class="post-meta-divider">|</span>
      <i class="fa fa-file-word-o"></i>
      <span>4498<span class="pc-show">字数</span></span>
    </span>
    
      <span id="/post/zVcsib6Ce/" class="meta-item pc-show leancloud_visitors">
        <span class="post-meta-divider">|</span>
        <i class="fa fa-eye"></i>
        <span>浏览量：<span class="leancloud-visitors-count" ></span></span>
      </span>
    
  </div>
</header>
              <div class="post-body next-md-body" id="post_body">
                <h1 id="局部变量和全局变量">局部变量和全局变量</h1>
<h2 id="局部变量">局部变量</h2>
<p>在我们学习函数之前，我们所理解的变量，只不过是在内存中开辟一个存储数据的位置，并取了个我们好懂的名字而已。因为我们之前写的程序只有一个主函数，因此我们觉得，定义了一个变量，就应该可以随时调用。但是学习了函数之后，我们发现，不同函数之间的变量是不能够相互调用的，这又是为什么呢？</p>
<p>比如：</p>
<pre><code class="language-c">//Example 01
#include &lt;stdio.h&gt;
int main(void)
{
    int i = 100;
    printf(&quot;Before i = %d\n&quot;, i);
    for (int i = 0; i &lt;= 10; i++)//再定义一个局部变量i
    {
        printf(&quot;i = %d\n&quot;, i);
    }
    printf(&quot;After i = %d\n&quot;, i);
    return 0;
}
</code></pre>
<p>结果如下：</p>
<pre><code>//Consequence 01
Before i = 100
i = 0
i = 1
i = 2
i = 3
i = 4
i = 5
i = 6
i = 7
i = 8
i = 9
i = 10
After i = 100
</code></pre>
<p>我们可以看到，我们在<code>for</code>函数里和<code>main</code>函数里都有一个<code>i</code>变量，但是我们在<code>for</code>函数里面定义的<code>i</code>却对外层函数不构成影响。</p>
<p>一般来说，变量名应该是不能够重复的。但是，由于我们定义的位置不一样（在不同的函数中），所以变量名重复又变得合法起来。这就是局部变量的特性：<strong>只能在自己的领域里面发挥作用</strong>。</p>
<p>像我们刚刚定义的<code>for</code>一样，C语言允许随处定义变量。也就是说，变量在需要用到的时候再定义。这样也符合我们的思维方式。因为当程序很庞大的时候，没有人愿意翻到顶上去看一个变量的注释。</p>
<h2 id="全局变量">全局变量</h2>
<p>既然有局部变量，那么全局变量也照样不可少。看下面的例子：</p>
<pre><code class="language-c">//Example 02
#include &lt;stdio.h&gt;
void f1(void);
void f2(void);
void f3(void);
int a = 0;//定义一个全局变量

void f1(void)
{
    a++;
}

void f2(void)
{
    a++;
}

void f3(void)
{
    a++;
}

int main(void)
{
    f1();
    f2();
    f3();
    printf(&quot;a = %d\n&quot;, ++a);
    return 0;
}
</code></pre>
<p>运行结果如下：</p>
<pre><code>//Consequence 02
a = 4
</code></pre>
<p>我们发现，全局变量在每一个函数里面的更改都“有效”，也就是说，全局变量是贯穿整个程序始终的。</p>
<p>有的小伙伴可能会好奇，如果全局变量和局部变量重名了，会发生什么呢？</p>
<p>那我们就来试试：</p>
<pre><code class="language-c">//Example 03
#include &lt;stdio.h&gt;
void f(void);
int a, b = 100;
void f(void)
{
    int b;
    a = 50; b = 101;
    printf(&quot;func, a = %d, b = %d\n&quot;, a, b);
}

int main(void)
{
    printf(&quot;Main, a = %d, b = %d\n&quot;, a, b);
    f();
    printf(&quot;Main, a = %d, b = %d\n&quot;, a, b);
}
</code></pre>
<p>运行结果如下：</p>
<pre><code>//Consequence 03
Main, a = 0, b = 100
func, a = 50, b = 101
Main, a = 50, b = 100
</code></pre>
<p>我们发现，名字叫<code>a</code>的变量只有全局变量，那么被赋值之后就等于在函数<code>f()</code>中赋的值。但是<code>b</code>就不一样了。在函数<code>f()</code>中，也有一个变量叫做<code>b</code>，那么此时编译器的做法是，在函数<code>f()</code>里先暂时屏蔽全局变量<code>b</code>，使用自己的局部变量。等走出了函数<code>f()</code>，局部变量被释放。</p>
<p>而我们还发现一个问题，我们可以直接输出没有被初始化的<code>a</code>！这也是全局变量的一个特点，不同于局部变量，全局变量在没有手动初始化的时候，会被系统自动初始化为<code>0</code>而不是像局部变量那样的很小的一个很奇怪的数。</p>
<p>另外，如果没有需要，尽量不要大量使用全局变量。因为全局变量的内存将会伴随着这个程序，直到程序执行完毕。如果大量使用全局变量的话，可能会造成内存占用过多等问题。这在嵌入式开发这种领域，内存空间寸土寸金，不当使用全局变量会导致资源的浪费。其次，全局变量会造成程序可读性变差。最后，全局变量会使得程序牵连性变强，牵一发而动全身的情况可能会再次出现。</p>
<p>因此全局变量虽然是个好东西，但也要谨慎使用。</p>
<h1 id="作用域和链接属性">作用域和链接属性</h1>
<p>在上一节，我们简单地了解了不同的变量，它能够有不同的作用范围，那么这个范围，就是我们所说的<strong>作用域</strong>。C语言的编译器一共能够确认4种不同的作用域：<code>代码块作用域</code> <code>文件作用域</code> <code>原型作用域</code> <code>函数作用域</code></p>
<h2 id="代码块作用域">代码块作用域</h2>
<pre><code class="language-c">//Example 04
#include &lt;stdio.h&gt;
int main(void)
{
    int i = 1;
    {
        int i = 2;
        printf(&quot;i = %d\n&quot;, i);
    }
    {
        printf(&quot;i = %d\n&quot;, i);
        int i = 3;
        printf(&quot;i = %d\n&quot;, i);
    }
    printf(&quot;i = %d\n&quot;, i);
    return 0;
}
</code></pre>
<p>运行结果如下：</p>
<pre><code>//Consequence 04
i = 2
i = 1
i = 3
i = 1
</code></pre>
<p>我们通常管一个大括号里面的语句叫做代码块，那么看这个程序，一个代码块里面的变量只能作用于所在的代码块里，超出了的就无效了。若存在代码块嵌套，那么优先内层代码块的变量。这就是<strong>代码块作用域</strong>。</p>
<p>当然，有一点需要说说，就是函数的形参也是代码块作用域，只能作用于函数定义代码块里面，即便它没有写在代码块里面。</p>
<h2 id="文件作用域">文件作用域</h2>
<p>在任何代码块之外定义的变量，都具有<strong>文件作用域</strong>。它们的作用域是从变量声明开始，一直到文件尾结束。另外，函数名也是文件作用域，因为函数名本身也在代码块之外。</p>
<h2 id="原型作用域">原型作用域</h2>
<p>原型作用域只适合那些在函数原型中声明的参数名。我们知道，在声明一个函数的时候，形参的名字是可以不用写的，只需要把类型写好就行了。但是，其实不妨可以试试写上名字，即便这个名字和正式定义的时候形参的名字不一样，也是没问题的（当然这样做毫无意义），这其实就是原型作用域在起作用。</p>
<h2 id="函数作用域">函数作用域</h2>
<p>函数作用域只适用于<code>goto</code>语句的标签，作用是将<code>goto</code>语句的标签限定在一个函数的内部，避免出现重名的标签。</p>
<h2 id="链接属性">链接属性</h2>
<p>简单来说，编译器将源代码转换成机器码的时候需要有两个步骤：<strong>编译</strong>和<strong>链接</strong>。</p>
<p>所谓编译，就是将我们写的源代码转换为机器码，而链接，就是将相关的库文件添加进来。比如我们在写程序的时候加入的头文件，在最终生成的时候就是要链接进来的。</p>
<p>我们知道，大型程序是由很多源文件构成的，那么在不同的文件中的同名标识符，编译器是入场处理的呢？</p>
<p>在C语言中，链接属性一共有以下3种：</p>
<ul>
<li>external(外部的)：多个文件中声明的同名标识符表示同一个实体</li>
<li>internal(内部的)：单个文件中声明的同名标识符表示同一个实体</li>
<li>none(无)：声明的同名标识符被当作独立不同的实体。比如，函数的局部变量。</li>
</ul>
<p>默认情况下，具备文件作用域的标识符拥有<code>external</code>属性，也就是说，这种标识符允许跨文件访问。使用<code>static</code>可以使原先拥有<code>external</code>属性的标识符变为<code>internal</code>属性。但是<code>static</code>只能修改具有文件作用域的标识符，并且是不可逆修改。</p>
<h1 id="生存期和存储类型">生存期和存储类型</h1>
<h2 id="生存期">生存期</h2>
<p>上一节我们用空间的角度去解释了不同的变量，但其实，还可以从时间的角度来分析。</p>
<p>C语言的变量通常有两种生存期，静态存储期(static storage duration)和自动存储期(automatic storage duration)。</p>
<p>具有文件作用域的变量具有静态存储期（如全局变量），函数名也有静态存储期。静态存储期的变量在程序执行的期间内将一直占据存储空间。</p>
<p>具有代码块作用域的变量通常具有自动存储期（如局部变量和形参），具有自动存储期的变量将在代码块执行完毕的时候释放内存。</p>
<h2 id="存储类型">存储类型</h2>
<p>变量的存储类型实际上是指存储变量值的内存类型。C语言提供了5种存储类型：<code>auto</code> <code>register</code> <code>static</code> <code>extern</code> <code>typedef</code></p>
<h3 id="1-自动变量">1. 自动变量</h3>
<p>在代码块中声明的变量默认就是自动变量(auto)。</p>
<pre><code class="language-c">//Example 05
#include &lt;stdio.h&gt;
int main(void)
{
    auto int a, b, c;
    return 0;
}
</code></pre>
<p>但是由于是默认存储类型，所以<code>auto</code>一般不写也完全没问题。函数中的形参、局部变量以及复合语句中定义的局部变量都具有自动变量。自动变量拥有代码块作用域、自动存储期和空链接属性。</p>
<h3 id="2-寄存器变量">2. 寄存器变量</h3>
<p>如果你学过汇编语言，或者对计算机的原理比较了解的话，一定没少听说<strong>寄存器</strong>这个词。寄存及就集成在CPU内部，因此它和CPU之间的交流几乎可以说没有延迟。</p>
<p>如果你申请了寄存器变量，那么就有可能被存储到寄存器里面去。当然，编译器也有自己的优化方案，它会在程序运行的时候权衡哪些变量更应该被放到寄存器的位置，因此，你的申请只是做一个参考而已。那么那些没有被放入寄存器的变量就会成为<strong>自动变量</strong>，所以，寄存器变量和自动变量在很多地方是一样的，也拥有代码块作用域、自动存储期和空链接属性。</p>
<p>但是，如果是寄存器变量的话，那么理论上就没法通过**取地址运算符&amp;**来获取地址了，因为我们知道这个是针对内存的。</p>
<pre><code class="language-c">//Example 06
#include &lt;stdio.h&gt;
int main(void)
{
    register int i = 100;
    printf(&quot;addr of i is %p\n&quot;, &amp;i);
    return 0;
}
</code></pre>
<p>但是VS可能对这种代码有优化，将变量转换成自动变量了：</p>
<pre><code>//Consequence 06 of Visual Studio 2019
addr of i is 00CFFE90
</code></pre>
<h3 id="3-静态局部变量">3. 静态局部变量</h3>
<p><code>static</code>用于描述具有文件作用域的变量或者函数时，表示将其链接属性从<code>external</code>修改成<code>internal</code>，它的作用范围就变成了仅当前文件可访问。如果<code>static</code>用于描述局部变量，那可就不太一样了。</p>
<p>默认情况下，局部变量是自动变量，具有自动存储期。如果使用了<code>static</code>来声明，那么就可以将局部变量指定为静态局部变量(static)。这使得局部变量具有静态存储期，所以它的生存期和全局变量一样。但是作用域依旧是局部变量，在别的函数中是无法访问这个局部变量的。</p>
<h3 id="4-extern">4.  extern</h3>
<p><code>extern</code>关键字告诉编译器这个变量或函数在别的地方已经定义过了，先在别的地方找找，不要急着报错。</p>
<p>通常情况下，这个关键词可以不写，但是为了程序更加完善，更加易读。在多人协作的时候，可以避免很多重名的问题。</p>
<h3 id="5-typedef">5.  typedef</h3>
<p><code>typedef</code>与其他四个存储类型的语义不同，<code>typedef</code>与内存存储无关，用于为数据类型定义一个新名字。</p>
<h1 id="递归">递归</h1>
<p>虽然递归隶属于算法的范畴，但是几乎所有的程序语言教程，都会讲到这个知识点。因为，递归是一个非常好的编程思路，有时候一个很难解决的问题，使用递归就可以巧妙地搞定。</p>
<h2 id="什么是递归">什么是递归</h2>
<p>递归说白了，就是函数在执行的时候，调用自身的行为。其实递归在生活中有很多实例，比如：</p>
<ol>
<li>
<p>汉诺塔游戏</p>
<figure data-type="image" tabindex="1"><img src="https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=2591095191,1547695417&amp;fm=26&amp;gp=0.jpg" alt="汉诺塔游戏" loading="lazy"></figure>
<p>这个游戏要求将中间的柱子的圆盘全部移动到另外一个柱子上，要求每次只能移动一个圆盘，并且较大的圆盘始终在下方。</p>
</li>
<li>
<p>谢尔宾斯基三角形</p>
<figure data-type="image" tabindex="2"><img src="https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=3361120212,184359007&amp;fm=26&amp;gp=0.jpg" alt="谢尔宾斯基三角形" loading="lazy"></figure>
<p>三角形里边填充三角形，只要空间够大，它可以撑满整个宇宙。</p>
</li>
</ol>
<p>甚至还诞生了一门数学分支：分形几何。专门研究这种递归现象。</p>
<p>说了这么多，那么递归在程序里面该如何实现呢？</p>
<pre><code class="language-c">//Example 07
#include &lt;stdio.h&gt;
void r(void);
void r(void)
{
    printf(&quot;Hi!&quot;);
    r();
}
int main(void)
{
    r();
    return 0;
}
</code></pre>
<p>运行结果如下：</p>
<pre><code>//Consequence 08
...
Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Segmentation fault
</code></pre>
<p>可以看到，满屏幕的Hi！这就是初学者经常会犯的错误，程序无休止地执行下去，直到消耗掉所有的内存。这就像我们讲过的“从前有座山，山里有座庙……”这个故事一样，没有中止的条件，讲多久都讲不完。</p>
<p>修改下代码：</p>
<pre><code class="language-c">//Example 07 V2
#include &lt;stdio.h&gt;
void r(void);
void r(void)
{
    static int count = 5;//设置计数变量
    printf(&quot;Hi!\n&quot;);
    if (--count)//设置跳出条件
    {
        r();
    }
}

int main(void)
{
    r();
    return 0;
}
</code></pre>
<p>运行结果如下：</p>
<pre><code>//Consequence 07 V2
Hi!
Hi!
Hi!
Hi!
Hi!
</code></pre>
<p>这样，递归这头小猛兽，就这样被我们控制住了。</p>
<h2 id="递归求斐波那契数列">递归求斐波那契数列</h2>
<p>斐波那契数列每一项等于前两项之和，正好符合递归的思路：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
int fibo(int n)
{
    if (n &lt;= 2)
    {
        return 1;
    }
    else
    {
        return fibo(n - 1) + fibo(n - 2);
    }
}
int main()
{
    int n;
    printf(&quot;请输入斐波那契数列长度：&quot;);
    scanf(&quot;%d&quot;, &amp;n);
    for (int i = 1; i &lt;= n; ++i)
    {
        printf(&quot;%d&quot;, fibo(i));
        if (i &lt; n)
        {
            printf(&quot;, &quot;);
        }
    }
    return 0;
}
</code></pre>
<p>程序执行如下：</p>
<pre><code>请输入斐波那契数列长度：10
1, 1, 2, 3, 5, 8, 13, 21, 34, 55
</code></pre>
<h2 id="递归求汉诺塔">递归求汉诺塔</h2>
<p>其实，不论有多少层汉诺塔，都可以使用递归一层一层往下解包。</p>
<pre><code class="language-c">//Example 08
#include &lt;stdio.h&gt;
void hanoi(int, char, char, char);
void hanoi(int n, char x, char y, char z)
{
    if (n == 1)
    {
        printf(&quot;%c --&gt; %c\n&quot;, x, z);//剩下底部的圆盘
    }
    else
    {
        hanoi(n - 1, x, z, y);//将n-1个圆盘从x移动到y
        printf(&quot;x --&gt; z\n&quot;);
        hanoi(n - 1, y, x, z);//将n-1个圆盘从y移动到z
    }
}
int main(void)
{
    int n;
    printf(&quot;请输入汉诺塔的层数：&quot;);
    scanf(&quot;%d&quot;, &amp;n);
    hanoi(n, 'X', 'Y', 'Z');
    return 0;
}
</code></pre>
<p>运行结果如下：</p>
<pre><code>//Consequence 08
请输入汉诺塔的层数：4
X --&gt; Y
x --&gt; z
Y --&gt; Z
x --&gt; z
Z --&gt; X
x --&gt; z
X --&gt; Y
x --&gt; z
Y --&gt; Z
x --&gt; z
Z --&gt; X
x --&gt; z
X --&gt; Y
x --&gt; z
Y --&gt; Z
</code></pre>
<h2 id="分治法">分治法</h2>
<p>所谓分治法，就是大事化小的思维。递归实际上就是一种分治。层层递归，然后从最简单的问题开始解决。</p>
<p>说到这里，就不得不提到一种排序算法，就是十分经典的——快速排序。</p>
<p>作为20世纪十大算法之一，快速排序的基本思想是：通过一项将待排序数据分割成独立的两部分，其中一部分元素均比另一部分小，然后分别对这两部分继续排序，重复步骤直到完成。</p>
<figure data-type="image" tabindex="3"><img src="https://www.cxyxiaowu.com/wp-content/uploads/2019/10/1571057581-e7b9d65b41e66df.gif" alt="快速排序动画演示" loading="lazy"></figure>
<p>代码如下：</p>
<pre><code class="language-c">//Example 09
#include &lt;stdio.h&gt;
void qs(int, int, int);
void qs(int array[], int left, int right)
{
    int i = left, j = right;
    int temp;
    int pivot;
    
    //基准点设置为中间元素，当然别的也可以
    pivot = array[(left + right) / 2];
    
    while (i &lt;= j)
    {
        //找到左边大于等于基准点的元素
        while (array[i] &lt; pivot)
        {
            ++i;
        }
        //找到右边小于等于基准点的元素
        while (array[j] &gt; pivot)
        {
            --j;
        }
        //如果左边下标小于右边，则交换元素
        if (i &lt;= j)
        {
            temp = array[i];
            array[i] = array[j];
            array[j] = temp;
            ++i;
            --j;
        }
    }
    
    //递归遍历左子
    if (left &lt; j)
    {
        qs(array, left, j);
    }
    //递归遍历右子
    if (i &lt; right)
    {
        qs(array, i, right);
    }
}

int main(void)
{
    int array[] = {135, 156, 120, 102, 130, 62, 410, 158, 173, 113, 124, 184, 131, 214};
    int length;
    length = sizeof(array) / sizeof(array[0]);
    qs(array, 0, length - 1);
    
    printf(&quot;排序后结果为：&quot;);
    for (int i = 0; i &lt; length; i++)
    {
        printf(&quot;%d&quot;, array[i]);
        if (i &lt; length - 1)
        {
            printf(&quot;, &quot;);
        }
    }
    putchar('\n');
    return 0;
}
</code></pre>
<p>执行结果如下：</p>
<pre><code>//Consequence 09
排序后结果为：62, 102, 113, 120, 124, 130, 131, 135, 156, 158, 173, 184, 214, 410
</code></pre>
<p>学了这么多，也该好好休息下了！下期再见！</p>

              </div>
              <div class="post-footer">
  <ul class="post-copyright">
    <li class="post-copyright-author">
      <strong>本文作者：</strong>
      Madara
    </li>
    <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://yeming.site/post/zVcsib6Ce/" title="NexT-TechZone">NexT-TechZone</a>
    </li>
    <li class="post-copyright-license">
      <strong>版权声明： </strong>
      本博客所有文章除特别声明外，转载请注明出处！
    </li>
  </ul>
  <div class="tags">
    
  </div>
  <div class="nav">
    <div class="nav-prev">
      
    </div>
    <div class="nav-next">
      
        <a class="nav-pc-next" title="最新版NexT主题使用教程" href="https://yeming.site/post/Och5LtMIu/">最新版NexT主题使用教程</a>
        <a class="nav-mobile-next" title="最新版NexT主题使用教程" href="https://yeming.site/post/Och5LtMIu/">下一篇</a>
        <i class="fa fa-chevron-right"></i>
      
    </div>
  </div>
</div>
              
                
<script src="https://cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js"></script>
<div id="vcomments" style="padding: 10px 0px 0px 0px"></div>
<script>
new Valine({
    el: '#vcomments' ,
    appId: 'MudG5LjoytmIhsrwdEXPzp2y-gzGzoHsz',
    appKey: 'TLzYWUI2DEK7cnCkkmjbn1Ih',
    notify: 'true' === '', 
    avatar:'monsterid', 
    placeholder: 'Just Go',
    pageSize: '',
    lang: 'zh-cn',
    visitor: 'true' === 'true',
    highlight: 'true' === 'normal',
    avatarForce: 'true' === 'true',
});
</script>
              
            </div>
          </div>
        </div>
      </div>
      <div class="footer-box">
  <footer class="footer">
    <div class="copyright">
      Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | © 2019-2020 Theme By HsxyHao
    </div>
    <div class="poweredby">
      
    </div>
  </footer>
  
  
  <div class="gemini back-to-top" id="back_to_top">
    <i class="fa fa-arrow-up"></i>
    
    <span class="scrollpercent">
      <span id="back_to_top_text">0</span>%
    </span>
    
  </div>
  
    <div class="bg-img">
      <img src="/media/images/custom-bgImg.jpg" />
    </div>
  
  
  
    
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css">
  <script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script>
  <div class="aplayer" id="aplayer"></div>
  <input hidden id="player_cover" value="/media/images/custom-cover.jpg" />
  <div class="music-list">
  
    
    <input hidden value="光るなら ,Goose house,https://cn-south-17-aplayer-46154810.oss.dogecdn.com/hikarunara.mp3," />
  
  </div>
  <script>
  let musics = document.querySelector('.music-list').children;
  let mediaMusic = [];
  let cover = document.querySelector('#player_cover').value;
  for (let i = 0; i < musics.length; i++) {
    let item = musics[i];
    let splits = item.value.split(',');
    mediaMusic.push({
      name: splits[0],
      artist: splits[1],
      url: splits[2],
      lrc: splits[3],
      cover: cover
    });
  }
  console.log(mediaMusic);
  const ap = new APlayer({
      container: document.getElementById('aplayer'),
      fixed: true,
      lrcType: 3,
      listFolded: false,
      listMaxHeight: 90,
      audio: mediaMusic
  });
  </script>


  
</div>
<script>

  let sideBarOpen = 'sidebar-open';
  let body = document.body;
  let back2Top = document.querySelector('#back_to_top'),
  back2TopText = document.querySelector('#back_to_top_text'),
  drawerBox = document.querySelector('#drawer_box'),
  rightSideBar = document.querySelector('.sidebar'),
  viewport = document.querySelector('body');

  function scrollAnimation(currentY, targetY) {
   
    let needScrollTop = targetY - currentY
    let _currentY = currentY
    setTimeout(() => {
      const dist = Math.ceil(needScrollTop / 10)
      _currentY += dist
      window.scrollTo(_currentY, currentY)
      if (needScrollTop > 10 || needScrollTop < -10) {
        scrollAnimation(_currentY, targetY)
      } else {
        window.scrollTo(_currentY, targetY)
      }
    }, 1)
  }

  back2Top.addEventListener("click", function(e) {
    scrollAnimation(document.scrollingElement.scrollTop, 0);
    e.stopPropagation();
    return false;
  });
  
  window.addEventListener('scroll', function(e) {
    let percent = document.scrollingElement.scrollTop / (document.scrollingElement.scrollHeight - document.scrollingElement.clientHeight) * 100;
    if (percent > 1 && !back2Top.classList.contains('back-top-active')) {
      back2Top.classList.add('back-top-active');
    }
    if (percent == 0) {
      back2Top.classList.remove('back-top-active');
    }
    if (back2TopText) {
      back2TopText.textContent = Math.floor(percent);
    }
  });

  
  let hasCacu = false;
  window.onresize = function() {
    if (window.width > 991) {
      calcuHeight();
    } else {
      hasCacu = false;
    }
  }

  function calcuHeight() {
    // 动态调整站点概览高度
    if (!hasCacu && back2Top.classList.contains('pisces') || back2Top.classList.contains('gemini')) {
      let sideBar = document.querySelector('.sidebar');
      let navUl = document.querySelector('#site_nav');
      sideBar.style = 'margin-top:' + (navUl.offsetHeight + navUl.offsetTop + 15) + 'px;';
      hasCacu = true;
    }
  }
  calcuHeight();
  
  let open = false, MOTION_TIME = 300, RIGHT_MOVE_DIS = '320px';

  if (drawerBox) {
    let rightMotions = document.querySelectorAll('.right-motion');
    let right = drawerBox.classList.contains('right');

    let transitionDir = right ? "transition.slideRightIn" : "transition.slideLeftIn";

    let openProp, closeProp;
    if (right) {
      openProp = {
        paddingRight: RIGHT_MOVE_DIS 
      };
      closeProp = {
        paddingRight: '0px'
      };
    } else {
      openProp = {
        paddingLeft: RIGHT_MOVE_DIS 
      };
      closeProp = {
        paddingLeft: '0px'
      };
    }

    drawerBox.onclick = function() {
      open = !open;
      window.Velocity(rightSideBar, 'stop');
      window.Velocity(viewport, 'stop');
      window.Velocity(rightMotions, 'stop');
      if (open) {
        window.Velocity(rightSideBar, {
          width: RIGHT_MOVE_DIS
        }, {
          duration: MOTION_TIME,
          begin: function() {
            window.Velocity(rightMotions, transitionDir,{ });
          }
        })
        window.Velocity(viewport, openProp,{
          duration: MOTION_TIME
        });
      } else {
        window.Velocity(rightSideBar, {
          width: '0px'
        }, {
          duration: MOTION_TIME,
          begin: function() {
            window.Velocity(rightMotions, {
              opacity: 0
            });
          }
        })
        window.Velocity(viewport, closeProp ,{
          duration: MOTION_TIME
        });
      }
      for (let i = 0; i < drawerBox.children.length; i++) {
        drawerBox.children[i].classList.toggle('muse-line');
      }
      drawerBox.classList.toggle(sideBarOpen);
    }
  }

  // 代码高亮
  hljs.initHighlightingOnLoad();

</script>
    </div>
  </body>
  <script src="/media/js/motion.js"></script>
</html>