<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://hsxyhao.github.io</id>
    <title>Madara</title>
    <updated>2019-12-19T09:23:40.231Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://hsxyhao.github.io"/>
    <link rel="self" href="https://hsxyhao.github.io/atom.xml"/>
    <subtitle>这个人很懒，什么都不想写...</subtitle>
    <logo>https://hsxyhao.github.io/images/avatar.png</logo>
    <icon>https://hsxyhao.github.io/favicon.ico</icon>
    <rights>All rights reserved 2019, Madara</rights>
    <entry>
        <title type="html"><![CDATA[消息队列学习开篇]]></title>
        <id>https://hsxyhao.github.io/post/xiao-xi-dui-lie-xue-xi-kai-pian</id>
        <link href="https://hsxyhao.github.io/post/xiao-xi-dui-lie-xue-xi-kai-pian">
        </link>
        <updated>2019-12-10T01:20:16.000Z</updated>
        <summary type="html"><![CDATA[<p>什么是消息队列？消息队列有哪些？又解决了哪些问题？该怎么选择消息队列？使用消息队列的时候会遇到哪些问题？带着这些疑问先对消息队列进行初步了解。<br>
<img src="https://hsxyhao.github.io/post-images/1576199469901.png" alt=""></p>
<h1 id="介绍">介绍</h1>
<p>在计算机科学中，消息队列（英语：Message queue）是一种进程间通信或同一进程的不同线程间的通信方式，软件的贮列用来处理一系列的输入，通常是来自用户。消息队列提供了异步的通信协议，每一个贮列中的纪录包含详细说明的数据，包含发生的时间，输入设备的种类，以及特定的输入参数，也就是说：消息的发送者和接收者不需要同时与消息队列交互。消息会保存在队列中，直到接收者取回它。<br>
一个 WIMP 环境像是 Microsoft Windows，借由优先的某些形式（通常是事件的时间或是重要性的顺序）来存储用户产生的事件到一个 事件贮列 中。系统把每个事件从事件贮列中传递给目标的应用程序。          <a href="https://zh.wikipedia.org/wiki/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97">——摘自维基百科</a></p>
<blockquote>
<p>维基百科中的解释，但是总感觉一大串术语，又是进程又是通信的，还有各种设备什么的。对于小白来说就用最简单的一句话就行了，消息队列就是用来发送和接收消息的<strong>队列</strong>，发送消息方叫作<strong>生产者</strong>，接收消息方叫作<strong>消费者</strong>。<br>
不要纠结这些专业术语了，我们了解消息队列主要用来业务上的问题的，老是按照专业的角度去理解多费事😜</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<p>什么是消息队列？消息队列有哪些？又解决了哪些问题？该怎么选择消息队列？使用消息队列的时候会遇到哪些问题？带着这些疑问先对消息队列进行初步了解。<br>
<img src="https://hsxyhao.github.io/post-images/1576199469901.png" alt=""></p>
<h1 id="介绍">介绍</h1>
<p>在计算机科学中，消息队列（英语：Message queue）是一种进程间通信或同一进程的不同线程间的通信方式，软件的贮列用来处理一系列的输入，通常是来自用户。消息队列提供了异步的通信协议，每一个贮列中的纪录包含详细说明的数据，包含发生的时间，输入设备的种类，以及特定的输入参数，也就是说：消息的发送者和接收者不需要同时与消息队列交互。消息会保存在队列中，直到接收者取回它。<br>
一个 WIMP 环境像是 Microsoft Windows，借由优先的某些形式（通常是事件的时间或是重要性的顺序）来存储用户产生的事件到一个 事件贮列 中。系统把每个事件从事件贮列中传递给目标的应用程序。          <a href="https://zh.wikipedia.org/wiki/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97">——摘自维基百科</a></p>
<blockquote>
<p>维基百科中的解释，但是总感觉一大串术语，又是进程又是通信的，还有各种设备什么的。对于小白来说就用最简单的一句话就行了，消息队列就是用来发送和接收消息的<strong>队列</strong>，发送消息方叫作<strong>生产者</strong>，接收消息方叫作<strong>消费者</strong>。<br>
不要纠结这些专业术语了，我们了解消息队列主要用来业务上的问题的，老是按照专业的角度去理解多费事😜</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Redis淘汰机制]]></title>
        <id>https://hsxyhao.github.io/post/redis-tao-tai-ji-zhi</id>
        <link href="https://hsxyhao.github.io/post/redis-tao-tai-ji-zhi">
        </link>
        <updated>2019-12-05T06:01:00.000Z</updated>
        <summary type="html"><![CDATA[<p>说到Redis的内存淘汰机制，突然我联想到之前上大学时候的手机内存不够用的问题。记得那时候买的是16G的5s，🍎手机都知道，非常耐用，用了四年都不卡，所以手机里存了大量的东西，导致手机经常提示内存不够用。我就经常删除手机里的图片，当时我的策略就是将手机里最不重要的照片以及很少会用到的照片删除掉，现在想想当初买手机的时候真应该买内存大一些的了。其实这里我删除手机照片的思考方式就有点类似Redis的内存淘汰机制了。</p>
<h1 id="淘汰策略">淘汰策略</h1>
<p>Redis的内存淘汰机制就是为了淘汰掉一些数据，保证Redis的正常服务。可以通过在配置文件中添加maxmemery-policy选择不同的淘汰策略，具体的策略有以下几种：</p>
<ul>
<li>noeviction 不进行任何淘汰操作，当内存不够时写命令会报错</li>
<li>allkeys-lru 在所有的key中查找最近<strong>最少使用</strong>的key进行淘汰</li>
<li>volatile-lru 在设置过期时间的key中查找最近<strong>最少使用</strong>的key进行淘汰</li>
<li>allkeys-random 在所有的key中随机移除某个key</li>
<li>volatile-random 在设置了过期时间的key中随机移除某个key</li>
<li>volatile-ttl 在设置了过期时间的key中，删除过期时间最早的key</li>
<li>allkeys-lfu 在所有的key中查找最近<strong>访问频率最低</strong>的key进行淘汰（4.0版本）</li>
<li>volatile-lfu 在设置过期时间的key中查找最近<strong>访问频率最低</strong>的key进行淘汰（4.0版本）</li>
</ul>
<p><strong>备注</strong><br>
这里删除的key其实只删除一个，这是因为Redis在执行具有申请内存的命令时，会先判断内存是否超过maxmemery，如果超过了就会基于设置的maxmemery-policy策略删除key。</p>
]]></summary>
        <content type="html"><![CDATA[<p>说到Redis的内存淘汰机制，突然我联想到之前上大学时候的手机内存不够用的问题。记得那时候买的是16G的5s，🍎手机都知道，非常耐用，用了四年都不卡，所以手机里存了大量的东西，导致手机经常提示内存不够用。我就经常删除手机里的图片，当时我的策略就是将手机里最不重要的照片以及很少会用到的照片删除掉，现在想想当初买手机的时候真应该买内存大一些的了。其实这里我删除手机照片的思考方式就有点类似Redis的内存淘汰机制了。</p>
<h1 id="淘汰策略">淘汰策略</h1>
<p>Redis的内存淘汰机制就是为了淘汰掉一些数据，保证Redis的正常服务。可以通过在配置文件中添加maxmemery-policy选择不同的淘汰策略，具体的策略有以下几种：</p>
<ul>
<li>noeviction 不进行任何淘汰操作，当内存不够时写命令会报错</li>
<li>allkeys-lru 在所有的key中查找最近<strong>最少使用</strong>的key进行淘汰</li>
<li>volatile-lru 在设置过期时间的key中查找最近<strong>最少使用</strong>的key进行淘汰</li>
<li>allkeys-random 在所有的key中随机移除某个key</li>
<li>volatile-random 在设置了过期时间的key中随机移除某个key</li>
<li>volatile-ttl 在设置了过期时间的key中，删除过期时间最早的key</li>
<li>allkeys-lfu 在所有的key中查找最近<strong>访问频率最低</strong>的key进行淘汰（4.0版本）</li>
<li>volatile-lfu 在设置过期时间的key中查找最近<strong>访问频率最低</strong>的key进行淘汰（4.0版本）</li>
</ul>
<p><strong>备注</strong><br>
这里删除的key其实只删除一个，这是因为Redis在执行具有申请内存的命令时，会先判断内存是否超过maxmemery，如果超过了就会基于设置的maxmemery-policy策略删除key。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Vim命令]]></title>
        <id>https://hsxyhao.github.io/post/vim-ming-ling-ji-lu</id>
        <link href="https://hsxyhao.github.io/post/vim-ming-ling-ji-lu">
        </link>
        <updated>2019-12-05T01:00:51.000Z</updated>
        <summary type="html"><![CDATA[<p>今天在公司领导问了个vim的命令，当时脑子一片空白，一时间语无伦次，场面甚是尴尬，真是书到用时方恨少啊！😰<br>
作为一名后端开发，在日常开发的过程中肯定会接触到使用vim快捷命令，基本上都是用到的时候直接度娘，虽然会接触到一些常用的vim命令，毕竟不是运维，过段时间基本上会再次忘掉，下次在遇见的时候再度娘。期间难免会耽搁不少时间，但是我觉得特地学一下vim，又感觉有点力不从心，上班不比上学，不是每天都可以划水。最后想了下觉得应该把用到的vim命令记录下来，方便下次查阅，后面有时间的时候也翻一下，就当做记单词了吧。</p>
]]></summary>
        <content type="html"><![CDATA[<p>今天在公司领导问了个vim的命令，当时脑子一片空白，一时间语无伦次，场面甚是尴尬，真是书到用时方恨少啊！😰<br>
作为一名后端开发，在日常开发的过程中肯定会接触到使用vim快捷命令，基本上都是用到的时候直接度娘，虽然会接触到一些常用的vim命令，毕竟不是运维，过段时间基本上会再次忘掉，下次在遇见的时候再度娘。期间难免会耽搁不少时间，但是我觉得特地学一下vim，又感觉有点力不从心，上班不比上学，不是每天都可以划水。最后想了下觉得应该把用到的vim命令记录下来，方便下次查阅，后面有时间的时候也翻一下，就当做记单词了吧。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Redis高可用]]></title>
        <id>https://hsxyhao.github.io/post/redis-gao-ke-yong</id>
        <link href="https://hsxyhao.github.io/post/redis-gao-ke-yong">
        </link>
        <updated>2019-11-23T09:51:53.000Z</updated>
        <summary type="html"><![CDATA[<p>Redis的高可用实现方案有哪些，为什么要选择官方的哨兵模式，自己开发自动化故障转移脚本有什么问题。redis cluster重定向有几种？redis数据分区...</p>
]]></summary>
        <content type="html"><![CDATA[<p>Redis的高可用实现方案有哪些，为什么要选择官方的哨兵模式，自己开发自动化故障转移脚本有什么问题。redis cluster重定向有几种？redis数据分区...</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Redis复制]]></title>
        <id>https://hsxyhao.github.io/post/redis-copy</id>
        <link href="https://hsxyhao.github.io/post/redis-copy">
        </link>
        <updated>2019-11-19T08:19:22.000Z</updated>
        <summary type="html"><![CDATA[<p>什么是redis的复制，为什么要有复制功能，全量复制有什么问题，部分复制又解决了哪些问题。</p>
<p>复制就是将redis节点中的数据复制完同步到其他节点中，在redis中参与复制一般有主节点(master)以及从节点(slave)，将数据从主节点复制到从节点，并且复制的方式是单向的，不能逆向复制，在建立复制关系之后主节点的数据会同步到从节点直到解除主从关系。不论是哨兵模式还是redis集群都是在复制的基础上完成的。</p>
<p><strong>记忆点</strong></p>
<ol>
<li>使用方式：建立、断开复制、安全性、只读性</li>
<li>适用场景：哨兵、集群</li>
<li>复制原理：建立复制、全量复制、部分复制、心跳</li>
<li>常见问题：读写分离、数据不一致、避免全量复制</li>
</ol>
]]></summary>
        <content type="html"><![CDATA[<p>什么是redis的复制，为什么要有复制功能，全量复制有什么问题，部分复制又解决了哪些问题。</p>
<p>复制就是将redis节点中的数据复制完同步到其他节点中，在redis中参与复制一般有主节点(master)以及从节点(slave)，将数据从主节点复制到从节点，并且复制的方式是单向的，不能逆向复制，在建立复制关系之后主节点的数据会同步到从节点直到解除主从关系。不论是哨兵模式还是redis集群都是在复制的基础上完成的。</p>
<p><strong>记忆点</strong></p>
<ol>
<li>使用方式：建立、断开复制、安全性、只读性</li>
<li>适用场景：哨兵、集群</li>
<li>复制原理：建立复制、全量复制、部分复制、心跳</li>
<li>常见问题：读写分离、数据不一致、避免全量复制</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Redis 持久化]]></title>
        <id>https://hsxyhao.github.io/post/redis-chi-jiu-hua</id>
        <link href="https://hsxyhao.github.io/post/redis-chi-jiu-hua">
        </link>
        <updated>2019-11-16T09:04:43.000Z</updated>
        <summary type="html"><![CDATA[<p>持久化有哪几种方式，各有什么问题。每种持久化的流程是什么样的，AOF重写是什么机制，解决了什么问题，fork底层函数，COW机制。</p>
<h1 id="面试">面试</h1>
<p>在面试的时候如果被问到Redis持久化的时候，怎么回答比较好？我想从以下几个角度展开，一定会让面试官眼前一亮。</p>
<ul>
<li>RDB冷备份以及AOF热备份</li>
<li>fork函数</li>
<li>COW（Copy on write）写时复制机制</li>
<li>AOF命令重写</li>
</ul>
]]></summary>
        <content type="html"><![CDATA[<p>持久化有哪几种方式，各有什么问题。每种持久化的流程是什么样的，AOF重写是什么机制，解决了什么问题，fork底层函数，COW机制。</p>
<h1 id="面试">面试</h1>
<p>在面试的时候如果被问到Redis持久化的时候，怎么回答比较好？我想从以下几个角度展开，一定会让面试官眼前一亮。</p>
<ul>
<li>RDB冷备份以及AOF热备份</li>
<li>fork函数</li>
<li>COW（Copy on write）写时复制机制</li>
<li>AOF命令重写</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Redis入门知识点]]></title>
        <id>https://hsxyhao.github.io/post/rui-shi-jun-dao-redis</id>
        <link href="https://hsxyhao.github.io/post/rui-shi-jun-dao-redis">
        </link>
        <updated>2019-11-14T07:49:23.000Z</updated>
        <summary type="html"><![CDATA[<p>redis有哪些基础数据结构，什么是快速链表，什么是跳跃链表，使用redis特有的数据类型可以实现哪些有趣的功能。</p>
<blockquote>
<p>Redis is an open source (BSD licensed), in-memory data structure store, used as a database, cache and message broker. It supports data structures such as strings, hashes, lists, sets, sorted sets with range queries, bitmaps, hyperloglogs, geospatial indexes with radius queries and streams. Redis has built-in replication, Lua scripting, LRU eviction, transactions and different levels of on-disk persistence, and provides high availability via Redis Sentinel and automatic partitioning with Redis Cluster.</p>
</blockquote>
<figure data-type="image" tabindex="1"><img src="https://hsxyhao.github.io/post-images/1576199763145.png" alt=""></figure>
<p>上面一段话取自Redis官方的介绍，为什么要把它放在这里，我觉得这是介绍Redis最为标准的一段话，从用途、数据结构已经功能等多方面介绍，如果以后面试官叫你介绍下redis的话，我觉得可以直接把这段话背下来😌。至于为什么把Redis称为瑞士军刀，相信用过redis的人都会这么认为。</p>
]]></summary>
        <content type="html"><![CDATA[<p>redis有哪些基础数据结构，什么是快速链表，什么是跳跃链表，使用redis特有的数据类型可以实现哪些有趣的功能。</p>
<blockquote>
<p>Redis is an open source (BSD licensed), in-memory data structure store, used as a database, cache and message broker. It supports data structures such as strings, hashes, lists, sets, sorted sets with range queries, bitmaps, hyperloglogs, geospatial indexes with radius queries and streams. Redis has built-in replication, Lua scripting, LRU eviction, transactions and different levels of on-disk persistence, and provides high availability via Redis Sentinel and automatic partitioning with Redis Cluster.</p>
</blockquote>
<figure data-type="image" tabindex="1"><img src="https://hsxyhao.github.io/post-images/1576199763145.png" alt=""></figure>
<p>上面一段话取自Redis官方的介绍，为什么要把它放在这里，我觉得这是介绍Redis最为标准的一段话，从用途、数据结构已经功能等多方面介绍，如果以后面试官叫你介绍下redis的话，我觉得可以直接把这段话背下来😌。至于为什么把Redis称为瑞士军刀，相信用过redis的人都会这么认为。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Gridea搭建个人博客]]></title>
        <id>https://hsxyhao.github.io/post/gridea-setup</id>
        <link href="https://hsxyhao.github.io/post/gridea-setup">
        </link>
        <updated>2019-11-13T05:47:44.000Z</updated>
        <summary type="html"><![CDATA[<p>上大学的时候一直想弄一个博客系统，但是当时自己还是初学者，根本完不成，心想着等到以后技术长进一点之后准备弄一个，可是一直等到现在都没有弄起来。期间也玩过hexo、typecho等静态博客平台，但是当时没有好好管理，搭建好的博客在服务器到期后就没再弄了。无意间在掘金上看到了<a href="https://gridea.dev/">Gridea</a>，进入官网后发现颜值还挺高的，后面慢慢的了解后，才发现目前还是个小众平台，主题以及平台的功能都还不完善。但是平台提供写文章的功能还不错(好像当时没有使用hexo就是因为没有一个写文章的地方)，后来就决定使用它了，相信gridea也会越来越优秀💪。<br>
<img src="https://hsxyhao.github.io/post-images/1576203380178.png" alt=""><br>
顺带一张高颜值的美图欣赏一下🤣</p>
]]></summary>
        <content type="html"><![CDATA[<p>上大学的时候一直想弄一个博客系统，但是当时自己还是初学者，根本完不成，心想着等到以后技术长进一点之后准备弄一个，可是一直等到现在都没有弄起来。期间也玩过hexo、typecho等静态博客平台，但是当时没有好好管理，搭建好的博客在服务器到期后就没再弄了。无意间在掘金上看到了<a href="https://gridea.dev/">Gridea</a>，进入官网后发现颜值还挺高的，后面慢慢的了解后，才发现目前还是个小众平台，主题以及平台的功能都还不完善。但是平台提供写文章的功能还不错(好像当时没有使用hexo就是因为没有一个写文章的地方)，后来就决定使用它了，相信gridea也会越来越优秀💪。<br>
<img src="https://hsxyhao.github.io/post-images/1576203380178.png" alt=""><br>
顺带一张高颜值的美图欣赏一下🤣</p>
]]></content>
    </entry>
</feed>